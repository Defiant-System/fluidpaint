const Shaders={Fragment:{advect:`precision highp float;\n\nvarying vec2 v_coordinates;\n\nuniform sampler2D u_velocityTexture;\nuniform sampler2D u_inputTexture;\nuniform float u_deltaTime;\nuniform float u_dissipation;\nuniform vec2 u_resolution;\nuniform vec2 u_min;\nuniform vec2 u_max;\n\nvoid main () {\n\t//RK2\n\tvec2 coordinates = gl_FragCoord.xy;\n\tvec2 velocity = texture2D(u_velocityTexture, coordinates / u_resolution).rg * 100.0;\n\tvec2 halfCoordinates = coordinates - velocity * 0.5 * u_deltaTime;\n\tvec2 halfVelocity = texture2D(u_velocityTexture, clamp(halfCoordinates, u_min, u_max) / u_resolution).rg * 100.0;\n\tvec2 finalCoordinates = coordinates - halfVelocity * u_deltaTime;\n\n\tgl_FragColor = texture2D(u_inputTexture, clamp(finalCoordinates, u_min, u_max) / u_resolution) * u_dissipation;\n}\n`,splat:`precision highp float;\n\n#ifdef VELOCITY\nvarying vec2 v_previousVelocity;\nvarying vec2 v_velocity;\nuniform float u_velocityScale;\n#else\nuniform vec4 u_splatColor;\n#endif\n\nuniform float u_splatRadius;\n\nvarying vec2 v_previousPosition;\nvarying vec2 v_position;\n\nvarying vec2 v_quadPosition;\n\nvarying vec2 v_coordinates;\n\nfloat distanceToLine(vec2 a, vec2 b, vec2 p) {\n\tfloat dist = distance(a, b);\n\tvec2 direction = (b - a) / dist;\n\n\tfloat projectedDistance = dot(p - a, direction);\n\tprojectedDistance = clamp(projectedDistance, 0.0, dist);\n\n\tvec2 projectedPosition = a + projectedDistance * direction;\n\n\treturn distance(p, projectedPosition);\n}\n\nvec2 clampVelocity (vec2 vel) {\n\tfloat MAX_SPEED = 2.0;\n\n\tfloat speed = length(vel);\n\n\tif (speed > MAX_SPEED) {\n\t\tvel *= MAX_SPEED / speed;\n\t}\n\t\n\treturn vel;\n}\n\nvoid main () {\n\tfloat splatDistance = distanceToLine(v_previousPosition, v_position, v_quadPosition);\n\n\tfloat multiplier = max(1.0 - splatDistance / u_splatRadius, 0.0);\n\n\n\t#ifdef VELOCITY\n\t\tvec2 velocity = mix(v_previousVelocity, v_velocity, v_coordinates.x * 0.5 + 0.5);\n\t\tgl_FragColor = vec4(clampVelocity(velocity * u_velocityScale), 0.0, multiplier);\n\t#else\n\t\tgl_FragColor = vec4(u_splatColor.rgb, u_splatColor.a * multiplier);\n\t#endif\n}\n`,divergence:`precision highp float;\n\nvarying vec2 v_coordinates;\n\nuniform sampler2D u_velocityTexture;\n\nuniform vec2 u_resolution;\n\nvoid main () {\n\tvec2 coordinates = gl_FragCoord.xy / u_resolution;\n\tvec2 delta = 1.0 / u_resolution;\n\n\tvec2 left = texture2D(u_velocityTexture, coordinates + vec2(-delta.x, 0.0)).rg;\n\tvec2 right = texture2D(u_velocityTexture, coordinates + vec2(delta.x, 0.0)).rg;\n\tvec2 bottom = texture2D(u_velocityTexture, coordinates + vec2(0.0, -delta.y)).rg;\n\tvec2 top = texture2D(u_velocityTexture, coordinates + vec2(0.0, delta.y)).rg;\n\n\tfloat divergence = ((right.x - left.x) + (top.y - bottom.y)) / 2.0;\n\n\tgl_FragColor = vec4(divergence, 0.0, 0.0, 0.0);\n}\n`,jacobi:`precision highp float;\n\nvarying vec2 v_coordinates;\n\nuniform vec2 u_resolution;\n\nuniform sampler2D u_pressureTexture;\nuniform sampler2D u_divergenceTexture;\n\nvoid main () {\n\tvec2 coordinates = gl_FragCoord.xy / u_resolution;\n\tvec2 delta = 1.0 / u_resolution;\n\n\tfloat divergenceCenter = texture2D(u_divergenceTexture, coordinates).r;\n\n\tfloat center = texture2D(u_pressureTexture, coordinates).r;\n\tfloat left = texture2D(u_pressureTexture, coordinates + vec2(-delta.x, 0.0)).r;\n\tfloat right = texture2D(u_pressureTexture, coordinates + vec2(delta.x, 0.0)).r;\n\tfloat bottom = texture2D(u_pressureTexture, coordinates + vec2(0.0, -delta.y)).r;\n\tfloat top = texture2D(u_pressureTexture, coordinates + vec2(0.0, delta.y)).r;\n\n\tfloat newPressure = (left + right + bottom + top - divergenceCenter) / 4.0;\n\n\tgl_FragColor = vec4(newPressure, 0.0, 0.0, 0.0);\n}\n`,subtract:`precision highp float;\n\nvarying vec2 v_coordinates;\n\nuniform vec2 u_resolution;\n\nuniform sampler2D u_pressureTexture;\nuniform sampler2D u_velocityTexture;\n\nvoid main () {\n\tvec2 coordinates = gl_FragCoord.xy / u_resolution;\n\tvec2 delta = 1.0 / u_resolution;\n\n\tfloat center = texture2D(u_pressureTexture, coordinates).r;\n\tfloat left = texture2D(u_pressureTexture, coordinates + vec2(-delta.x, 0.0)).r;\n\tfloat right = texture2D(u_pressureTexture, coordinates + vec2(delta.x, 0.0)).r;\n\tfloat bottom = texture2D(u_pressureTexture, coordinates + vec2(0.0, -delta.y)).r;\n\tfloat top = texture2D(u_pressureTexture, coordinates + vec2(0.0, delta.y)).r;\n\n\t//compute gradient of pressure\n\tvec2 gradient = vec2(right - left, top - bottom) / 2.0;\n\n\tvec2 currentVelocity = texture2D(u_velocityTexture, coordinates).rg;\n\n\tvec2 newVelocity = currentVelocity - gradient;\n\n\tgl_FragColor = vec4(newVelocity, 0.0, 0.0);\n}\n`,resize:`precision highp float;\n\nuniform sampler2D u_paintTexture;\nuniform vec2 u_oldResolution;\nuniform vec2 u_offset; //in texels\nuniform float u_featherSize;\n\nvoid main () {\n\tvec2 coordinates = (gl_FragCoord.xy - u_offset) / u_oldResolution;\n\tvec4 value = texture2D(u_paintTexture, coordinates);\n\tvec2 featherSize = u_featherSize / u_oldResolution;\n\tfloat scale = smoothstep(-featherSize.x, 0.0, coordinates.x) * smoothstep(-featherSize.y, 0.0, coordinates.y)\n\t\t\t\t\t\t\t\t* smoothstep(1.0 + featherSize.x, 1.0, coordinates.x) * smoothstep(1.0 + featherSize.y, 1.0, coordinates.y);\n\n\tgl_FragColor = value * scale;\n}\n`,project:`//advects brush positions forward in time\n\nprecision highp float;\n\nuniform vec2 u_resolution;\n\nuniform sampler2D u_positionsTexture; \nuniform sampler2D u_velocitiesTexture;\nuniform sampler2D u_randomsTexture;\n\nuniform float u_damping;\nuniform float u_gravity;\n\nuniform float u_verticesPerBristle;\n\nfloat random (float n) {\n\treturn fract(0.5 + n * (0.6180339887498949));\n}\n\nvoid main () {\n\tvec2 coordinates = gl_FragCoord.xy / u_resolution;\n\n\tvec3 position = texture2D(u_positionsTexture, coordinates).rgb;\n\tvec3 velocity = texture2D(u_velocitiesTexture, coordinates).rgb;\n\n\tvelocity *= u_damping;\n\n\tvelocity += vec3(0.0, 0.0, -u_gravity);\n\n\tgl_FragColor = vec4(position + velocity, 1.0);\n}\n`,brush:`precision highp float;\n\nuniform vec4 u_color;\n\nvoid main () {\n\tgl_FragColor = u_color;\n}\n`,painting:`precision highp float;\n\nvarying vec2 v_coordinates;\nuniform sampler2D u_paintTexture;\nuniform vec2 u_paintingSize; //painting size in pixels\nuniform vec2 u_paintingPosition; //bottom left position in pixels\nuniform vec2 u_paintingResolution;\nuniform float u_normalScale;\nuniform vec3 u_lightDirection;\nuniform float u_roughness;\nuniform float u_F0;\nuniform float u_diffuseScale;\nuniform float u_specularScale;\n\n#ifdef RESIZING\nuniform float u_featherSize;\n#endif\n\n//samples with feathering at the edges\nvec4 samplePaintTexture (vec2 coordinates) {\n\tvec4 value = texture2D(u_paintTexture, coordinates);\n\n\t#ifdef RESIZING\n\t\tvec2 featherSize = u_featherSize / u_paintingResolution;\n\t\tfloat scale = smoothstep(-featherSize.x, 0.0, coordinates.x) * smoothstep(-featherSize.y, 0.0, coordinates.y)\n\t\t\t\t\t  * smoothstep(1.0 + featherSize.x, 1.0, coordinates.x) * smoothstep(1.0 + featherSize.y, 1.0, coordinates.y);\n\t\treturn value * scale;\n\t#else\n\t\treturn value;\n\t#endif\n}\n\n\nfloat getHeight (vec2 coordinates) {\n\treturn samplePaintTexture(coordinates).a;\n}\n\n\nvec2 computeGradient(vec2 coordinates) { //sobel operator\n\tvec2 delta = 1.0 / u_paintingResolution;\n\n\tfloat topLeft = getHeight(coordinates + vec2(-delta.x, delta.y));\n\tfloat top = getHeight(coordinates + vec2(0.0, delta.y));\n\tfloat topRight = getHeight(coordinates + vec2(delta.x, delta.y));\n\tfloat left = getHeight(coordinates + vec2(-delta.x, 0.0));\n\tfloat right = getHeight(coordinates + vec2(delta.x, 0.0));\n\tfloat bottomLeft = getHeight(coordinates + vec2(-delta.x, -delta.y));\n\tfloat bottom = getHeight(coordinates + vec2(0.0, -delta.y));\n\tfloat bottomRight = getHeight(coordinates + vec2(delta.x, -delta.y));\n\t\n\treturn vec2(\n\t\t 1.0 * topLeft - 1.0 * topRight + 2.0 * left - 2.0 * right + 1.0 * bottomLeft - 1.0 * bottomRight,\n\t\t-1.0 * topLeft + 1.0 * bottomLeft - 2.0 * top + 2.0 * bottom - 1.0 * topRight + 1.0 * bottomRight);\n}\n\n\nconst float PI = 3.14159265;\n\nfloat square (float x) {\n\treturn x * x;\n}\n\nfloat fresnel (float F0, float lDotH) {\n\tfloat f = pow(1.0 - lDotH, 5.0);\n\n\treturn (1.0 - F0) * f + F0;\n}\n\nfloat GGX (float alpha, float nDotH) {\n\tfloat a2 = square(alpha);\n\n\treturn a2 / (PI * square(square(nDotH) * (a2 - 1.0) + 1.0));\n}\n\nfloat GGGX (float alpha, float nDotL, float nDotV) {\n\tfloat a2 = square(alpha);\n\n\tfloat gl = nDotL + sqrt(a2 + (1.0 - a2) * square(nDotL));\n\tfloat gv = nDotV + sqrt(a2 + (1.0 - a2) * square(nDotV));\n\n\treturn 1.0 / (gl * gv);\n}\n\nfloat saturate (float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n\nfloat specularBRDF (vec3 lightDirection, vec3 eyeDirection, vec3 normal, float roughness, float F0) {\n\tvec3 halfVector = normalize(lightDirection + eyeDirection);\n\n\tfloat nDotH = saturate(dot(normal, halfVector));\n\tfloat nDotL = saturate(dot(normal, lightDirection));\n\tfloat nDotV = saturate(dot(normal, eyeDirection));\n\tfloat lDotH = saturate(dot(lightDirection, halfVector));\n\n\tfloat D = GGX(roughness, nDotH);\n\tfloat G = GGGX(roughness, nDotL, nDotV);\n\tfloat F = fresnel(F0, lDotH);\n\n\treturn D * G * F;\n}\n\nvoid main () {\n\tvec2 coordinates = (gl_FragCoord.xy - u_paintingPosition) / u_paintingSize;\n\tvec4 value = samplePaintTexture(coordinates); //r, g, b, height\n\tvec2 gradient = computeGradient(coordinates);\n\tvec3 normal = normalize(vec3(\n\t\tgradient.x,\n\t\tgradient.y,\n\t\tu_normalScale\n\t));\n\n\tvec3 lightDirection = normalize(u_lightDirection);\n\tvec3 eyeDirection = vec3(0.0, 0.0, 1.0);\n\n\tfloat diffuse = saturate(dot(lightDirection, normal));\n\tdiffuse = diffuse * u_diffuseScale + (1.0 - u_diffuseScale);\n\n\tfloat specular = specularBRDF(lightDirection, eyeDirection, normal, u_roughness, u_F0);\n\tvec3 surfaceColor = value.rgb * diffuse + specular * u_specularScale;\n\t\n\tgl_FragColor = vec4(surfaceColor.rgb, value.a);\n\t// gl_FragColor = vec4(surfaceColor.rgb, 1.0);\n}\n`,output:`precision highp float;\n\nvarying vec2 v_coordinates;\n\nuniform sampler2D u_input;\n\nvoid main () {\n\tgl_FragColor = texture2D(u_input, v_coordinates);\n#ifdef OUTPUT\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n}\n`,picker:`precision highp float;\n\nvarying vec2 v_coordinates; //in [-1, 1]\n\nuniform vec4 u_currentHSVA;\n\nuniform float u_innerRadius;\nuniform float u_outerRadius;\nuniform float u_squareWidth;\n\nuniform vec2 u_circlePosition;\n\nuniform vec2 u_alphaSliderPosition; //bottom left of alpha bar\nuniform vec2 u_alphaSliderDimensions;\n\nconst float PI = 3.14159265;\n\nvec3 trilinearInterpolate(vec3 p, vec3 v000, vec3 v100, vec3 v010, vec3 v001, vec3 v101, vec3 v011, vec3 v110, vec3 v111) {\n\treturn v000 * (1.0 - p.x) * (1.0 - p.y) * (1.0 - p.z) +\n\t\t   v100 * p.x * (1.0 - p.y) * (1.0 - p.z) +\n\t\t   v010 * (1.0 - p.x) * p.y * (1.0 - p.z) +\n\t\t   v001 * (1.0 - p.x) * (1.0 - p.y) * p.z +\n\t\t   v101 * p.x * (1.0 - p.y) * p.z +\n\t\t   v011 * (1.0 - p.x) * p.y * p.z +\n\t\t   v110 * p.x * p.y * (1.0 - p.z) +\n\t\t   v111 * p.x * p.y * p.z;\n}\n\nvec3 rybToRgb(vec3 ryb) {\n\t#ifdef RGB\n\t\treturn 1.0 - ryb.yxz;\n\t#endif\n\treturn ryb;\n\n\t// return trilinearInterpolate(ryb, \n\t// \tvec3(1.0, 1.0, 1.0), \n\t// \tvec3(1.0, 0.0, 0.0), \n\t// \tvec3(0.163, 0.373, 0.6), \n\t// \tvec3(1.0, 1.0, 0.0), \n\t// \tvec3(1.0, 0.5, 0.0), \n\t// \tvec3(0.0, 0.66, 0.2),\n\t// \tvec3(0.5, 0.0, 0.5),\n\t// \tvec3(0.2, 0.094, 0.0));\n}\n\nvec3 hsv2ryb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 hsvToRgb (vec3 hsv) {\n\treturn rybToRgb(hsv2ryb(hsv));\n}\n\nfloat circleStrokeAlpha (vec2 position, vec2 center, float innerRadius, float outerRadius, float feather) {\n\tfloat dist = distance(center, position);\n\treturn smoothstep(innerRadius - feather, innerRadius, dist) * smoothstep(outerRadius + feather, outerRadius, dist);\n}\n\nvec4 hueCircle () {\n\tvec2 coordinates = v_coordinates - u_circlePosition;\n\n\tfloat angle = atan(coordinates.y, coordinates.x) + 2.0 * PI;\n\tfloat hue = angle / (2.0 * PI);\n\t\n\tvec3 circleRGB = hsvToRgb(vec3(hue, 1.0, 1.0));\n\n\tfloat radius = length(coordinates);\n\tfloat circleAlpha = circleStrokeAlpha(coordinates, vec2(0.0, 0.0), u_innerRadius, u_outerRadius, 1.5);\n\n\treturn vec4(circleRGB, circleAlpha);\n}\n\nfloat boxAlpha (vec2 position, vec2 bottomLeft, vec2 dimensions, vec2 feather) {\n\tvec2 center = bottomLeft + dimensions * 0.5;\n\tvec2 distances = max(abs(position - center) - dimensions * 0.5, vec2(0.0, 0.0));\n\n\treturn smoothstep(feather.x, 0.0, distances.x) * smoothstep(feather.y, 0.0, distances.y);\n}\n\nfloat boxStrokeAlpha (vec2 position, vec2 bottomLeft, vec2 dimensions, vec2 strokeWidth, vec2 feather) {\n\treturn boxAlpha(position, bottomLeft - strokeWidth * 0.5, dimensions + strokeWidth, feather) *\n\t\t   (1.0 - boxAlpha(position, bottomLeft + strokeWidth * 0.5, dimensions - strokeWidth, feather));\n}\n\nvec4 sbSquare () {\n\tvec2 coordinates = v_coordinates - u_circlePosition;\n\n\tfloat saturation = clamp((coordinates.x - (-u_squareWidth / 2.0)) / u_squareWidth, 0.0, 1.0);\n\tfloat lightness = clamp((coordinates.y - (-u_squareWidth / 2.0)) / u_squareWidth, 0.0, 1.0);\n\n\tvec3 squareRYB = hsv2ryb(vec3(u_currentHSVA.x, saturation, lightness));\n\tvec3 squareRGB = rybToRgb(squareRYB);\n\n\tfloat squareAlpha = boxAlpha(coordinates, vec2(-u_squareWidth * 0.5), vec2(u_squareWidth), vec2(1.0));\n\n\treturn vec4(squareRGB, squareAlpha);\n}\n\n\nvec4 hueIndicator () {\n\tfloat hueIndicatorAngle = u_currentHSVA.x * PI * 2.0;\n\n\tvec2 coordinates = v_coordinates - u_circlePosition;\n\tfloat angle = atan(coordinates.y, coordinates.x);\n\n\n\tfloat relativeAngle = angle - hueIndicatorAngle; //angle relative to the hue indicator\n\tif (relativeAngle > PI) relativeAngle -= 2.0 * PI;\n\tif (relativeAngle < -PI) relativeAngle += 2.0 * PI;\n\n\tfloat indicatorWidth = 0.2;\n\n\tfloat radius = length(coordinates);\n\n\tfloat strokeWidth = 3.0;\n\tfloat strokeFeather = 1.5;\n\n\tfloat alpha = boxStrokeAlpha(vec2(radius, relativeAngle), vec2(u_innerRadius, -indicatorWidth * 0.5), vec2(u_outerRadius - u_innerRadius, indicatorWidth), vec2(strokeWidth, strokeWidth / u_innerRadius), vec2(strokeFeather, strokeFeather / u_innerRadius));\n\n\treturn vec4(1.0, 1.0, 1.0, alpha);\n}\n\n\nvec4 sbIndicator () {\n\tfloat innerRadius = 8.0;\n\n\tvec2 indicatorPosition = vec2(\n\t\tu_circlePosition.x - u_squareWidth * 0.5 + innerRadius + u_currentHSVA.y * (u_squareWidth - innerRadius * 2.0),\n\t\tu_circlePosition.y - u_squareWidth * 0.5 + innerRadius + u_currentHSVA.z * (u_squareWidth - innerRadius * 2.0));\n\n\tfloat alpha = circleStrokeAlpha(v_coordinates, indicatorPosition, innerRadius, innerRadius + 2.0, 1.5);\n\n\treturn vec4(1.0, 1.0, 1.0, alpha);\n}\n\n\n\nvec4 alphaSlider () {\n\tfloat feather = 0.75;\n\tfloat alpha = smoothstep(u_alphaSliderPosition.x - feather, u_alphaSliderPosition.x, v_coordinates.x) *\n\t\t\t\t\tsmoothstep(u_alphaSliderPosition.x + u_alphaSliderDimensions.x + feather, u_alphaSliderPosition.x + u_alphaSliderDimensions.x, v_coordinates.x) *\n\t\t\t\t\tsmoothstep(u_alphaSliderPosition.y - feather, u_alphaSliderPosition.y, v_coordinates.y) *\n\t\t\t\t\tsmoothstep(u_alphaSliderPosition.y + u_alphaSliderDimensions.y + feather, u_alphaSliderPosition.y + u_alphaSliderDimensions.y, v_coordinates.y);\n\n\tfloat t = (v_coordinates.y - u_alphaSliderPosition.y) / u_alphaSliderDimensions.y;\n\n\tvec2 coordinates = v_coordinates - u_alphaSliderPosition;\n\tcoordinates = floor(coordinates / 5.0);\n\tfloat checkerboard = mod(coordinates.x + mod(coordinates.y, 2.0), 2.0) * 0.05 + 0.95;\n\n\tvec3 color = mix(vec3(checkerboard), hsvToRgb(u_currentHSVA.rgb), (v_coordinates.y - u_alphaSliderPosition.y) / u_alphaSliderDimensions.y);\n\n\treturn vec4(color, alpha);\n}\n\nvec4 alphaIndicator () {\n\tfloat indicatorHeight = 15.0;\n\tfloat indicatorY = u_alphaSliderPosition.y + u_currentHSVA.a * (u_alphaSliderDimensions.y - indicatorHeight);\n\n\tfloat strokeWidth = 3.0;\n\tfloat strokeFeather = 1.5;\n\tfloat alpha = boxStrokeAlpha(v_coordinates, vec2(u_alphaSliderPosition.x, indicatorY), vec2(u_alphaSliderDimensions.x, indicatorHeight), vec2(strokeWidth), vec2(strokeFeather));\n\n\treturn vec4(1.0, 1.0, 1.0, alpha);\n}\n\nvec4 alphaBlend (vec4 color, vec4 source) {\n\tvec4 result = vec4(0.0);\n\tresult.rgb = source.a * source.rgb + (1.0 - source.a) * color.rgb;\n\tresult.a = 1.0 * source.a + (1.0 - source.a) * color.a;\n\n\treturn result;\n}\n\nvoid main () {\n\tvec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n\n\tvec4 sbSquareColor = sbSquare();\n\tcolor = alphaBlend(color, sbSquareColor);\n\t\n\tvec4 sbIndicatorColor = sbIndicator();\n\tcolor = alphaBlend(color, sbIndicatorColor);\n\n\tvec4 hueCircleColor = hueCircle();\n\tcolor = alphaBlend(color, hueCircleColor);\n\n\tvec4 hueIndicatorColor = hueIndicator();\n\tcolor = alphaBlend(color, hueIndicatorColor);\n\n\tvec4 alphaSliderColor = alphaSlider();\n\tcolor = alphaBlend(color, alphaSliderColor);\n\n\tvec4 alphaIndicatorColor = alphaIndicator();\n\tcolor = alphaBlend(color, alphaIndicatorColor);\n\n\tgl_FragColor = color;\n}\n`,setbristles:`precision highp float;\n\nuniform vec3 u_brushPosition;\nuniform float u_brushScale;\nuniform float u_bristleCount;\n\nuniform float u_bristleLength; //length of total bristle\nuniform float u_verticesPerBristle;\n\nuniform sampler2D u_randomsTexture;\nuniform vec2 u_resolution;\n\nuniform float u_jitter;\n\nconst float PHI = 1.618033988749895;\nconst float PI = 3.14159265;\n\nvoid main () {\n\tvec2 coordinates = gl_FragCoord.xy / u_resolution;\n\n\tvec4 randoms = texture2D(u_randomsTexture, coordinates);\n\n\tfloat bristleIndex = floor(gl_FragCoord.x); //which bristle\n\tfloat vertexIndex = floor(gl_FragCoord.y);\n\n\t//jittered sunflower distribution\n\n\tfloat theta = (bristleIndex + (randoms.z - 0.5) * u_jitter) * 2.0 * PI / (PHI * PHI);\n\tfloat r = sqrt(bristleIndex + (randoms.w - 0.5) * u_jitter) / sqrt(u_bristleCount);\n\n\tfloat spacing = u_bristleLength / (u_verticesPerBristle - 1.0);\n\tvec3 brushSpaceBristlePosition = vec3(r * cos(theta), r * sin(theta), -vertexIndex * spacing);\n\n\tvec3 bristlePosition = u_brushPosition + brushSpaceBristlePosition * u_brushScale;\n\n\tgl_FragColor = vec4(bristlePosition, 1.0);\n}\n`,updatevelocity:`//updates velocity with projectedPosition - position\n\nprecision highp float;\n\nuniform vec2 u_resolution;\n\nuniform sampler2D u_positionsTexture; \nuniform sampler2D u_projectedPositionsTexture;\n\nvoid main () {\n\tvec2 coordinates = gl_FragCoord.xy / u_resolution;\n\n\tvec3 velocity = texture2D(u_projectedPositionsTexture, coordinates).rgb - texture2D(u_positionsTexture, coordinates).rgb;\n\n\tgl_FragColor = vec4(velocity, 1.0);\n}\n`,planeconstraint:`precision highp float;\n\nuniform vec2 u_resolution;\n\nuniform sampler2D u_positionsTexture;\n\nvoid main () {\n\tvec2 coordinates = gl_FragCoord.xy / u_resolution;\n\n\tvec3 position = texture2D(u_positionsTexture, coordinates).rgb;\n\n\tif (position.z < 0.0) position.z *= 0.5;\n\n\tgl_FragColor = vec4(position, 1.0);\n\n}\n`,bendingconstraint:`precision highp float;\n\nuniform vec2 u_resolution;\nuniform sampler2D u_positionsTexture;\nuniform sampler2D u_randomsTexture;\nuniform float u_pointCount;\nuniform int u_pass; //0, 1 or 2, 0 means we do 0-1-2, 3-4-5, 6-7-8, 1 means we do 1-2-3, 4-5-6, 7-8-9, 2 means we do 2-3-4, 5-6-7, 8-9-10\nuniform float u_stiffnessVariation;\n\nfloat length2(vec3 v) {\n\treturn v.x * v.x + v.y * v.y + v.z * v.z;\n}\n\nvoid main () {\n\tvec2 coordinates = gl_FragCoord.xy / u_resolution;\n\n\tfloat index = gl_FragCoord.y;\n\tfloat baseIndex = floor((index - float(u_pass)) / 3.0) * 3.0 + float(u_pass); //the base index of this a, b, c pair\n\n\tindex = floor(index);\n\n\tif (baseIndex >= 0.0 && baseIndex < u_pointCount - 2.0) {\n\t\tfloat aIndex = baseIndex;\n\t\tfloat bIndex = baseIndex + 1.0;\n\t\tfloat cIndex = baseIndex + 2.0;\n\n\t\tvec3 aPos = texture2D(u_positionsTexture, vec2(coordinates.x, (aIndex + 0.5) / u_pointCount)).rgb;\n\t\tfloat aW = 1.0;\n\t\tif (aIndex < 0.1) aW = 0.0;\n\n\t\tvec3 bPos = texture2D(u_positionsTexture, vec2(coordinates.x, (bIndex + 0.5) / u_pointCount)).rgb;\n\t\tfloat bW = 1.0;\n\n\t\tvec3 cPos = texture2D(u_positionsTexture, vec2(coordinates.x, (cIndex + 0.5) / u_pointCount)).rgb;\n\t\tfloat cW = 1.0;\n\n\t\tvec3 r1 = (bPos - aPos) / distance(aPos, bPos);\n\t\tvec3 r2 = (cPos - bPos) / distance(bPos, cPos);\n\n\t\tfloat constraint = dot(r1, r2) - 1.0;\n\t\tfloat random = texture2D(u_randomsTexture, vec2(coordinates.x, 0.5 / u_pointCount)).g;\n\t\tfloat stiffness = random * u_stiffnessVariation;\n\n\t\tif (constraint > -1.0) {\n\t\t\tvec3 gradA = (dot(r1, r2) * r1 - r2) / max(distance(aPos, bPos), 0.0001);\n\t\t\tvec3 gradC = (-dot(r1, r2) * r2 + r1) / max(distance(bPos, cPos), 0.0001);\n\t\t\tvec3 gradB = -gradA - gradC;\n\n\t\t\tfloat s = stiffness * constraint / max(aW * length2(gradA) + bW * length2(gradB) + cW * length2(gradC), 0.0001);\n\t\t\tvec3 newPosition;\n\t\t\tif (index == aIndex) {\n\t\t\t\tvec3 currentPosition = aPos;\n\t\t\t\tnewPosition = currentPosition - s * gradA * aW;\n\t\t\t} else if (index == bIndex) {\n\t\t\t\tvec3 currentPosition = bPos;\n\t\t\t\tnewPosition = currentPosition - s * gradB * bW;\n\t\t\t} else if (index == cIndex) {\n\t\t\t\tvec3 currentPosition = cPos;\n\t\t\t\tnewPosition = currentPosition - s * gradC * cW;\n\t\t\t}\n\n\t\t\tgl_FragColor = vec4(newPosition, 0.0);\n\t\t} else {\n\t\t\tgl_FragColor = texture2D(u_positionsTexture, coordinates).rgba;\n\t\t}\n\t} else {\n\t\tgl_FragColor = texture2D(u_positionsTexture, coordinates).rgba;\n\t}\n}\n`,distanceconstraint:`precision highp float;\n\nuniform int u_pass; //0 or 1, in pass 0 we do 0-1, 2-3, 4-5..., in pass 1 we do 1-2, 3-4, 5-6...\n\nuniform vec2 u_resolution;\n\nuniform sampler2D u_positionsTexture;\nuniform float u_pointCount;\n\nuniform float u_targetDistance;\n\nvoid main () {\n\tvec2 coordinates = gl_FragCoord.xy / u_resolution;\n\n\tfloat index = floor(gl_FragCoord.y); //which vertex on the bristle\n\n\tfloat myWeight = 1.0;\n\tif (index < 0.1) myWeight = 0.0;\n\n\tvec3 myPosition = texture2D(u_positionsTexture, vec2(coordinates.x, (index + 0.5) / u_pointCount)).rgb;\n\n\tfloat otherIndex = 0.0;\n\n\tif (mod(index, 2.0) < 0.01) {\n\t\tif (u_pass == 0) {\n\t\t\totherIndex = index + 1.0;\n\t\t} else {\n\t\t\totherIndex = index - 1.0;\n\t\t}\n\t} else {\n\t\tif (u_pass == 0) {\n\t\t\totherIndex = index - 1.0;\n\t\t} else {\n\t\t\totherIndex = index + 1.0;\n\t\t}\n\t}\n\n\tfloat otherWeight = 1.0;\n\tif (otherIndex < 0.1) otherWeight = 0.0;\n\n\tvec3 newPosition = myPosition;\n\n\tif (otherIndex >= 0.0 && otherIndex < u_pointCount) {\n\t\tvec3 otherPosition = texture2D(u_positionsTexture, vec2(coordinates.x, (otherIndex + 0.5) / u_pointCount)).rgb;\n\n\t\tfloat currentDistance = distance(myPosition, otherPosition);\n\t\tvec3 towards = (otherPosition - myPosition) / max(currentDistance, 0.01);\n\n\t\tnewPosition = myPosition + (myWeight / (myWeight + otherWeight)) * (currentDistance - u_targetDistance) * towards;\n\t} \n\n\tgl_FragColor = vec4(newPosition, 1.0);\n\n}\n`},Vertex:{splat:`precision highp float;\n\nattribute vec4 a_splatCoordinates; //(texCoord.x, texCoord.y, quad x (-1 or 1), quad y (-1 or 1))\n\nuniform vec2 u_paintingDimensions;\nuniform vec2 u_paintingPosition;\nuniform float u_splatRadius;\nuniform float u_zThreshold;\n\nuniform sampler2D u_positionsTexture;\nuniform sampler2D u_previousPositionsTexture;\n\nvarying vec2 v_coordinates; //in [-1, 1]\n\nvarying vec2 v_previousPosition;\nvarying vec2 v_position;\n\nvarying vec2 v_quadPosition;\n\n#ifdef VELOCITY\n\tuniform sampler2D u_velocitiesTexture;\n\tuniform sampler2D u_previousVelocitiesTexture;\n\n\tvarying vec2 v_velocity;\n\tvarying vec2 v_previousVelocity;\n#endif\n\nvoid main () {\n\tvec2 coordinates = a_splatCoordinates.zw; //in [-1, 1]\n\n\tvec3 position = texture2D(u_positionsTexture, a_splatCoordinates.xy).rgb;\n\tvec3 previousPosition = texture2D(u_previousPositionsTexture, a_splatCoordinates.xy).rgb;\n\n\tif (position.z > u_zThreshold) {\n\t\tposition = vec3(100000000.0, 1000000.0, 100000000.0);\n\t\tpreviousPosition = vec3(100000000.0, 1000000.0, 100000000.0);\n\t}\n\n\tvec2 planarPosition = position.xy;\n\tvec2 previousPlanarPosition = previousPosition.xy;\n\n\tvec2 mid = (planarPosition + previousPlanarPosition) * 0.5;\n\t\n\n\tfloat dist = distance(previousPlanarPosition.xy, planarPosition.xy);\n\tvec2 direction = (planarPosition - previousPlanarPosition) / dist;\n\tvec2 tangent = vec2(-direction.y, direction.x);\n\n\n\tvec2 finalPosition = mid + coordinates.x * direction * (dist * 0.5 + u_splatRadius) + coordinates.y * tangent * u_splatRadius;\n\n\t//finalPosition = mid + coordinates * u_splatRadius;\n   \n\n\tv_previousPosition = previousPlanarPosition;\n\tv_position = planarPosition;\n\tv_quadPosition = finalPosition;\n\n\n\tv_coordinates = a_splatCoordinates.zw;\n\n\tgl_Position = vec4(-1.0 + 2.0 * (finalPosition - u_paintingPosition) / u_paintingDimensions, 0.0, 1.0);\n\t\n#ifdef VELOCITY\n\tvec3 velocity = texture2D(u_velocitiesTexture, a_splatCoordinates.xy).rgb;\n\tvec3 previousVelocity = texture2D(u_previousVelocitiesTexture, a_splatCoordinates.xy).rgb;\n\n\tv_velocity = velocity.xy;\n\tv_previousVelocity = previousVelocity.xy;\n#endif\n\n}\n`,brush:`precision highp float;\n\nuniform vec2 u_canvasDimensions;\n\nuniform mat4 u_projectionViewMatrix;\n\nattribute vec2 a_textureCoordinates; //coordinates of this vertex into the brush texture\n\nuniform sampler2D u_positionsTexture;\n\nvoid main () {\n\tvec3 position = texture2D(u_positionsTexture, a_textureCoordinates).rgb;\n\n\tvec4 outPos = u_projectionViewMatrix * vec4(position, 1.0);\n\toutPos.z = 0.0;\n\n\tgl_Position = outPos;\n}\n`,picker:`precision highp float;\n\nattribute vec2 a_position;\n\nvarying vec2 v_coordinates; //in ([0, width], [0, height])\n\nuniform vec2 u_resolution;\n\nuniform vec2 u_screenResolution;\nuniform vec2 u_position;\nuniform vec2 u_dimensions;\n\nvoid main () {\n\tv_coordinates = (a_position * 0.5 + 0.5) * u_resolution;\n\n\tvec2 screenPosition = u_position + (a_position * 0.5 + 0.5) * u_dimensions;\n\n\tgl_Position = vec4((screenPosition / u_screenResolution) * 2.0 - 1.0, 0.0, 1.0);\n}\n`,painting:`precision highp float;\n\nattribute vec2 a_position;\n\nvarying vec2 v_coordinates;\n\nvoid main () {\n\tv_coordinates = a_position * 0.5 + 0.5;\n\n\tgl_Position = vec4(a_position, 0.0, 1.0);\n}\n`,fullscreen:`precision highp float;\n\nattribute vec2 a_position;\n\nvarying vec2 v_coordinates;\n\nvoid main () {\n\tv_coordinates = a_position * 0.5 + 0.5;\n\n\tgl_Position = vec4(a_position, 0.0, 1.0);\n}\n`}};let QUALITIES=[{name:"Low",resolutionScale:1},{name:"Medium",resolutionScale:1.5},{name:"High",resolutionScale:2}],InteractionMode={NONE:0,PAINTING:1,RESIZING:2,PANNING:3},INITIAL_QUALITY=0,MIN_PAINTING_WIDTH=300,MAX_PAINTING_WIDTH=4096,RESIZING_RADIUS=20,RESIZING_FEATHER_SIZE=2,NORMAL_SCALE=7,ROUGHNESS=.075,F0=.05,SPECULAR_SCALE=.5,DIFFUSE_SCALE=.15,LIGHT_DIRECTION=[0,1,1],HISTORY_SIZE=4;let N_PREVIOUS_SPEEDS=15,THIN_MIN_ALPHA=.002,THIN_MAX_ALPHA=.08,THICK_MIN_ALPHA=.002,THICK_MAX_ALPHA=.025,MAX_BRISTLE_COUNT=100,MIN_BRISTLE_COUNT=10,MIN_BRUSH_SCALE=5,MAX_BRUSH_SCALE=75,Z_THRESHOLD=.13333,VERTICES_PER_BRISTLE=10,BRISTLE_LENGTH=4.5,BRISTLE_JITTER=.5,ITERATIONS=20;let PRESSURE_JACOBI_ITERATIONS=2,FRAMES_TO_SIMULATE=60,SPLAT_PADDING=4.5,SPEED_PADDING=1.1;let CONSTANT_NAMES=["ACTIVE_ATTRIBUTES","ACTIVE_ATTRIBUTE_MAX_LENGTH","ACTIVE_TEXTURE","ACTIVE_UNIFORMS","ACTIVE_UNIFORM_MAX_LENGTH","ALIASED_LINE_WIDTH_RANGE","ALIASED_POINT_SIZE_RANGE","ALPHA","ALPHA_BITS","ALWAYS","ARRAY_BUFFER","ARRAY_BUFFER_BINDING","ATTACHED_SHADERS","BACK","BLEND","BLEND_COLOR","BLEND_DST_ALPHA","BLEND_DST_RGB","BLEND_EQUATION","BLEND_EQUATION_ALPHA","BLEND_EQUATION_RGB","BLEND_SRC_ALPHA","BLEND_SRC_RGB","BLUE_BITS","BOOL","BOOL_VEC2","BOOL_VEC3","BOOL_VEC4","BROWSER_DEFAULT_WEBGL","BUFFER_SIZE","BUFFER_USAGE","BYTE","CCW","CLAMP_TO_EDGE","COLOR_ATTACHMENT0","COLOR_BUFFER_BIT","COLOR_CLEAR_VALUE","COLOR_WRITEMASK","COMPILE_STATUS","COMPRESSED_TEXTURE_FORMATS","CONSTANT_ALPHA","CONSTANT_COLOR","CONTEXT_LOST_WEBGL","CULL_FACE","CULL_FACE_MODE","CURRENT_PROGRAM","CURRENT_VERTEX_ATTRIB","CW","DECR","DECR_WRAP","DELETE_STATUS","DEPTH_ATTACHMENT","DEPTH_BITS","DEPTH_BUFFER_BIT","DEPTH_CLEAR_VALUE","DEPTH_COMPONENT","DEPTH_COMPONENT16","DEPTH_FUNC","DEPTH_RANGE","DEPTH_STENCIL","DEPTH_STENCIL_ATTACHMENT","DEPTH_TEST","DEPTH_WRITEMASK","DITHER","DONT_CARE","DST_ALPHA","DST_COLOR","DYNAMIC_DRAW","ELEMENT_ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER_BINDING","EQUAL","FASTEST","FLOAT","FLOAT_MAT2","FLOAT_MAT3","FLOAT_MAT4","FLOAT_VEC2","FLOAT_VEC3","FLOAT_VEC4","FRAGMENT_SHADER","FRAMEBUFFER","FRAMEBUFFER_ATTACHMENT_OBJECT_NAME","FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE","FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE","FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL","FRAMEBUFFER_BINDING","FRAMEBUFFER_COMPLETE","FRAMEBUFFER_INCOMPLETE_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_DIMENSIONS","FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT","FRAMEBUFFER_UNSUPPORTED","FRONT","FRONT_AND_BACK","FRONT_FACE","FUNC_ADD","FUNC_REVERSE_SUBTRACT","FUNC_SUBTRACT","GENERATE_MIPMAP_HINT","GEQUAL","GREATER","GREEN_BITS","HIGH_FLOAT","HIGH_INT","INCR","INCR_WRAP","INFO_LOG_LENGTH","INT","INT_VEC2","INT_VEC3","INT_VEC4","INVALID_ENUM","INVALID_FRAMEBUFFER_OPERATION","INVALID_OPERATION","INVALID_VALUE","INVERT","KEEP","LEQUAL","LESS","LINEAR","LINEAR_MIPMAP_LINEAR","LINEAR_MIPMAP_NEAREST","LINES","LINE_LOOP","LINE_STRIP","LINE_WIDTH","LINK_STATUS","LOW_FLOAT","LOW_INT","LUMINANCE","LUMINANCE_ALPHA","MAX_COMBINED_TEXTURE_IMAGE_UNITS","MAX_CUBE_MAP_TEXTURE_SIZE","MAX_FRAGMENT_UNIFORM_VECTORS","MAX_RENDERBUFFER_SIZE","MAX_TEXTURE_IMAGE_UNITS","MAX_TEXTURE_SIZE","MAX_VARYING_VECTORS","MAX_VERTEX_ATTRIBS","MAX_VERTEX_TEXTURE_IMAGE_UNITS","MAX_VERTEX_UNIFORM_VECTORS","MAX_VIEWPORT_DIMS","MEDIUM_FLOAT","MEDIUM_INT","MIRRORED_REPEAT","NEAREST","NEAREST_MIPMAP_LINEAR","NEAREST_MIPMAP_NEAREST","NEVER","NICEST","NONE","NOTEQUAL","NO_ERROR","NUM_COMPRESSED_TEXTURE_FORMATS","ONE","ONE_MINUS_CONSTANT_ALPHA","ONE_MINUS_CONSTANT_COLOR","ONE_MINUS_DST_ALPHA","ONE_MINUS_DST_COLOR","ONE_MINUS_SRC_ALPHA","ONE_MINUS_SRC_COLOR","OUT_OF_MEMORY","PACK_ALIGNMENT","POINTS","POLYGON_OFFSET_FACTOR","POLYGON_OFFSET_FILL","POLYGON_OFFSET_UNITS","RED_BITS","RENDERBUFFER","RENDERBUFFER_ALPHA_SIZE","RENDERBUFFER_BINDING","RENDERBUFFER_BLUE_SIZE","RENDERBUFFER_DEPTH_SIZE","RENDERBUFFER_GREEN_SIZE","RENDERBUFFER_HEIGHT","RENDERBUFFER_INTERNAL_FORMAT","RENDERBUFFER_RED_SIZE","RENDERBUFFER_STENCIL_SIZE","RENDERBUFFER_WIDTH","RENDERER","REPEAT","REPLACE","RGB","RGB5_A1","RGB565","RGBA","RGBA4","SAMPLER_2D","SAMPLER_CUBE","SAMPLES","SAMPLE_ALPHA_TO_COVERAGE","SAMPLE_BUFFERS","SAMPLE_COVERAGE","SAMPLE_COVERAGE_INVERT","SAMPLE_COVERAGE_VALUE","SCISSOR_BOX","SCISSOR_TEST","SHADER_COMPILER","SHADER_SOURCE_LENGTH","SHADER_TYPE","SHADING_LANGUAGE_VERSION","SHORT","SRC_ALPHA","SRC_ALPHA_SATURATE","SRC_COLOR","STATIC_DRAW","STENCIL_ATTACHMENT","STENCIL_BACK_FAIL","STENCIL_BACK_FUNC","STENCIL_BACK_PASS_DEPTH_FAIL","STENCIL_BACK_PASS_DEPTH_PASS","STENCIL_BACK_REF","STENCIL_BACK_VALUE_MASK","STENCIL_BACK_WRITEMASK","STENCIL_BITS","STENCIL_BUFFER_BIT","STENCIL_CLEAR_VALUE","STENCIL_FAIL","STENCIL_FUNC","STENCIL_INDEX","STENCIL_INDEX8","STENCIL_PASS_DEPTH_FAIL","STENCIL_PASS_DEPTH_PASS","STENCIL_REF","STENCIL_TEST","STENCIL_VALUE_MASK","STENCIL_WRITEMASK","STREAM_DRAW","SUBPIXEL_BITS","TEXTURE","TEXTURE0","TEXTURE1","TEXTURE2","TEXTURE3","TEXTURE4","TEXTURE5","TEXTURE6","TEXTURE7","TEXTURE8","TEXTURE9","TEXTURE10","TEXTURE11","TEXTURE12","TEXTURE13","TEXTURE14","TEXTURE15","TEXTURE16","TEXTURE17","TEXTURE18","TEXTURE19","TEXTURE20","TEXTURE21","TEXTURE22","TEXTURE23","TEXTURE24","TEXTURE25","TEXTURE26","TEXTURE27","TEXTURE28","TEXTURE29","TEXTURE30","TEXTURE31","TEXTURE_2D","TEXTURE_BINDING_2D","TEXTURE_BINDING_CUBE_MAP","TEXTURE_CUBE_MAP","TEXTURE_CUBE_MAP_NEGATIVE_X","TEXTURE_CUBE_MAP_NEGATIVE_Y","TEXTURE_CUBE_MAP_NEGATIVE_Z","TEXTURE_CUBE_MAP_POSITIVE_X","TEXTURE_CUBE_MAP_POSITIVE_Y","TEXTURE_CUBE_MAP_POSITIVE_Z","TEXTURE_MAG_FILTER","TEXTURE_MIN_FILTER","TEXTURE_WRAP_S","TEXTURE_WRAP_T","TRIANGLES","TRIANGLE_FAN","TRIANGLE_STRIP","UNPACK_ALIGNMENT","UNPACK_COLORSPACE_CONVERSION_WEBGL","UNPACK_FLIP_Y_WEBGL","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNSIGNED_BYTE","UNSIGNED_INT","UNSIGNED_SHORT","UNSIGNED_SHORT_4_4_4_4","UNSIGNED_SHORT_5_5_5_1","UNSIGNED_SHORT_5_6_5","VALIDATE_STATUS","VENDOR","VERSION","VERTEX_ATTRIB_ARRAY_BUFFER_BINDING","VERTEX_ATTRIB_ARRAY_ENABLED","VERTEX_ATTRIB_ARRAY_NORMALIZED","VERTEX_ATTRIB_ARRAY_POINTER","VERTEX_ATTRIB_ARRAY_SIZE","VERTEX_ATTRIB_ARRAY_STRIDE","VERTEX_ATTRIB_ARRAY_TYPE","VERTEX_SHADER","VIEWPORT","ZERO"];class SplatArea{constructor(t,e){this.rectangle=t;this.frameNumber=e}}class Snapshot{constructor(t,e,n,r){this.texture=t;this.paintingWidth=e;this.paintingHeight=n;this.resolutionScale=r}get textureWidth(){return Math.ceil(this.paintingWidth*this.resolutionScale)}get textureHeight(){return Math.ceil(this.paintingHeight*this.resolutionScale)}}class Brush{constructor(t,e,n){this.wgl=t;this.stiffnessVariation=.3;this.brushDamping=.15;this.gravity=30;this.maxBristleCount=n;this._bristleCount=e;this.projectProgram=t.createProgram(Shaders.Vertex.fullscreen,Shaders.Fragment.project);this.distanceConstraintProgram=t.createProgram(Shaders.Vertex.fullscreen,Shaders.Fragment.distanceconstraint);this.planeConstraintProgram=t.createProgram(Shaders.Vertex.fullscreen,Shaders.Fragment.planeconstraint);this.bendingConstraintProgram=t.createProgram(Shaders.Vertex.fullscreen,Shaders.Fragment.bendingconstraint);this.setBristlesProgram=t.createProgram(Shaders.Vertex.fullscreen,Shaders.Fragment.setbristles);this.updateVelocityProgram=t.createProgram(Shaders.Vertex.fullscreen,Shaders.Fragment.updatevelocity);this.positionsTexture=t.buildTexture(t.RGBA,t.FLOAT,n,VERTICES_PER_BRISTLE,null,t.CLAMP_TO_EDGE,t.CLAMP_TO_EDGE,t.LINEAR,t.LINEAR);this.previousPositionsTexture=t.buildTexture(t.RGBA,t.FLOAT,n,VERTICES_PER_BRISTLE,null,t.CLAMP_TO_EDGE,t.CLAMP_TO_EDGE,t.LINEAR,t.LINEAR);this.velocitiesTexture=t.buildTexture(t.RGBA,t.FLOAT,n,VERTICES_PER_BRISTLE,null,t.CLAMP_TO_EDGE,t.CLAMP_TO_EDGE,t.LINEAR,t.LINEAR);this.previousVelocitiesTexture=t.buildTexture(t.RGBA,t.FLOAT,n,VERTICES_PER_BRISTLE,null,t.CLAMP_TO_EDGE,t.CLAMP_TO_EDGE,t.LINEAR,t.LINEAR);this.projectedPositionsTexture=t.buildTexture(t.RGBA,t.FLOAT,n,VERTICES_PER_BRISTLE,null,t.CLAMP_TO_EDGE,t.CLAMP_TO_EDGE,t.LINEAR,t.LINEAR);this.projectedPositionsTextureTemp=t.buildTexture(t.RGBA,t.FLOAT,n,VERTICES_PER_BRISTLE,null,t.CLAMP_TO_EDGE,t.CLAMP_TO_EDGE,t.LINEAR,t.LINEAR);let r=[];for(let t=0;t<n;++t){for(let e=0;e<VERTICES_PER_BRISTLE;++e){let i=(t+.5)/n,o=(e+.5)/VERTICES_PER_BRISTLE;r.push(i);r.push(o)}}this.brushTextureCoordinatesBuffer=t.createBuffer();t.bufferData(this.brushTextureCoordinatesBuffer,t.ARRAY_BUFFER,new Float32Array(r),t.STATIC_DRAW);let i=[];for(let t=0;t<n*VERTICES_PER_BRISTLE*4;++t){i.push(Math.random())}this.randomsTexture=t.buildTexture(t.RGBA,t.FLOAT,n,VERTICES_PER_BRISTLE,new Float32Array(i),t.CLAMP_TO_EDGE,t.CLAMP_TO_EDGE,t.LINEAR,t.LINEAR);let o=8,s=[],a=[],u=0;for(let t=0;t<n;++t){for(let e=0;e<VERTICES_PER_BRISTLE-1;++e){for(let r=0;r<o;++r){let i=(r+.5)/o,l=(t+.5)/n,_=(e+.5+i)/VERTICES_PER_BRISTLE;s.push(l);s.push(_);s.push(-1);s.push(-1);s.push(l);s.push(_);s.push(1);s.push(-1);s.push(l);s.push(_);s.push(1);s.push(1);s.push(l);s.push(_);s.push(-1);s.push(1);a.push(u+0);a.push(u+1);a.push(u+2);a.push(u+2);a.push(u+3);a.push(u+0);u+=4}}}this.splatCoordinatesBuffer=t.createBuffer();t.bufferData(this.splatCoordinatesBuffer,t.ARRAY_BUFFER,new Float32Array(s),t.STATIC_DRAW);this.splatIndexBuffer=t.createBuffer();t.bufferData(this.splatIndexBuffer,t.ELEMENT_ARRAY_BUFFER,new Uint16Array(a),t.STATIC_DRAW);this.splatIndexCount=a.length;let l=[];this.indexCount=0;for(let t=0;t<n;++t){for(let e=0;e<VERTICES_PER_BRISTLE-1;++e){let n=t*VERTICES_PER_BRISTLE+e,r=t*VERTICES_PER_BRISTLE+e+1;l.push(n);l.push(r);this.indexCount+=2}}this.brushIndexBuffer=t.createBuffer();t.bufferData(this.brushIndexBuffer,t.ELEMENT_ARRAY_BUFFER,new Uint16Array(l),t.STATIC_DRAW);this.simulationFramebuffer=t.createFramebuffer();this.quadVertexBuffer=t.createBuffer();t.bufferData(this.quadVertexBuffer,t.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,-1,1,1]),t.STATIC_DRAW)}initialize(t,e,n,r){this.positionX=t;this.positionY=e;this.positionZ=n;this.scale=r;this.speeds=[];for(var i=0;i<N_PREVIOUS_SPEEDS;++i){this.speeds.push(0)}var o=this.wgl;var s=o.createDrawState().bindFramebuffer(this.simulationFramebuffer).viewport(0,0,this.bristleCount,VERTICES_PER_BRISTLE).useProgram(this.setBristlesProgram).uniform3f("u_brushPosition",this.positionX,this.positionY,this.positionZ).uniform1f("u_brushScale",this.scale).uniform1f("u_bristleCount",this.bristleCount).uniform1f("u_bristleLength",BRISTLE_LENGTH).uniform1f("u_verticesPerBristle",VERTICES_PER_BRISTLE).uniform1f("u_jitter",BRISTLE_JITTER).uniform2f("u_resolution",this.maxBristleCount,VERTICES_PER_BRISTLE).uniformTexture("u_randomsTexture",2,o.TEXTURE_2D,this.randomsTexture).vertexAttribPointer(this.quadVertexBuffer,this.setBristlesProgram.getAttribLocation("a_position"),2,o.FLOAT,false,0,0);o.framebufferTexture2D(this.simulationFramebuffer,o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_2D,this.positionsTexture,0);o.drawArrays(s,o.TRIANGLE_STRIP,0,4)}get bristleCount(){return this._bristleCount}set bristleCount(t){var e=this.wgl,n=this._bristleCount;if(t>n*100){var r=e.createDrawState().bindFramebuffer(this.simulationFramebuffer).viewport(n,0,t-n,VERTICES_PER_BRISTLE).useProgram(this.setBristlesProgram).uniform3f("u_brushPosition",this.positionX,this.positionY,this.positionZ).uniform1f("u_brushScale",this.scale).uniform1f("u_bristleCount",n).uniform1f("u_bristleLength",BRISTLE_LENGTH).uniform1f("u_verticesPerBristle",VERTICES_PER_BRISTLE).uniform1f("u_jitter",BRISTLE_JITTER).uniform2f("u_resolution",this.maxBristleCount,VERTICES_PER_BRISTLE).uniformTexture("u_randomsTexture",2,e.TEXTURE_2D,this.randomsTexture).vertexAttribPointer(this.quadVertexBuffer,this.setBristlesProgram.getAttribLocation("a_position"),2,e.FLOAT,false,0,0);e.framebufferTexture2D(this.simulationFramebuffer,e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.positionsTexture,0);e.drawArrays(r,e.TRIANGLE_STRIP,0,4)}this._bristleCount=t}get filteredSpeed(){return this.speeds.reduce((t,e)=>Math.max(t,e))}update(t,e,n,r){var i=t-this.positionX,o=e-this.positionY,s=n-this.positionZ,a=Math.sqrt(i*i+o*o+s*s);this.speeds.shift();this.speeds.push(a);this.positionX=t;this.positionY=e;this.positionZ=n;this.scale=r;var u=this.wgl;var l=u.createDrawState().bindFramebuffer(this.simulationFramebuffer).viewport(0,0,this._bristleCount,VERTICES_PER_BRISTLE).useProgram(this.projectProgram).uniformTexture("u_positionsTexture",0,u.TEXTURE_2D,this.positionsTexture).uniformTexture("u_velocitiesTexture",1,u.TEXTURE_2D,this.velocitiesTexture).uniformTexture("u_randomsTexture",2,u.TEXTURE_2D,this.randomsTexture).uniform1f("u_gravity",this.gravity).uniform1f("u_damping",this.brushDamping).uniform1f("u_verticesPerBristle",VERTICES_PER_BRISTLE).uniform2f("u_resolution",this.maxBristleCount,VERTICES_PER_BRISTLE).vertexAttribPointer(this.quadVertexBuffer,this.projectProgram.getAttribLocation("a_position"),2,u.FLOAT,false,0,0);u.framebufferTexture2D(this.simulationFramebuffer,u.FRAMEBUFFER,u.COLOR_ATTACHMENT0,u.TEXTURE_2D,this.projectedPositionsTexture,0);u.drawArrays(l,u.TRIANGLE_STRIP,0,4);var _=u.createDrawState().bindFramebuffer(this.simulationFramebuffer).viewport(0,0,this._bristleCount,1).useProgram(this.setBristlesProgram).uniform3f("u_brushPosition",this.positionX,this.positionY,this.positionZ).uniform1f("u_brushScale",this.scale).uniform1f("u_bristleCount",this._bristleCount).uniform1f("u_bristleLength",BRISTLE_LENGTH).uniform1f("u_jitter",BRISTLE_JITTER).uniform1f("u_verticesPerBristle",VERTICES_PER_BRISTLE).uniform2f("u_resolution",this.maxBristleCount,VERTICES_PER_BRISTLE).uniformTexture("u_randomsTexture",2,u.TEXTURE_2D,this.randomsTexture).vertexAttribPointer(this.quadVertexBuffer,this.setBristlesProgram.getAttribLocation("a_position"),2,u.FLOAT,false,0,0);u.framebufferTexture2D(this.simulationFramebuffer,u.FRAMEBUFFER,u.COLOR_ATTACHMENT0,u.TEXTURE_2D,this.projectedPositionsTexture,0);u.drawArrays(_,u.TRIANGLE_STRIP,0,4);for(var c=0;c<ITERATIONS;++c){u.framebufferTexture2D(this.simulationFramebuffer,u.FRAMEBUFFER,u.COLOR_ATTACHMENT0,u.TEXTURE_2D,this.projectedPositionsTexture,0);u.drawArrays(_,u.TRIANGLE_STRIP,0,4);for(var E=0;E<2;++E){var h=u.createDrawState().bindFramebuffer(this.simulationFramebuffer).viewport(0,0,this._bristleCount,VERTICES_PER_BRISTLE).useProgram(this.distanceConstraintProgram).uniformTexture("u_positionsTexture",0,u.TEXTURE_2D,this.projectedPositionsTexture).uniform1f("u_pointCount",VERTICES_PER_BRISTLE).uniform1f("u_targetDistance",this.scale*BRISTLE_LENGTH/(VERTICES_PER_BRISTLE-1)).uniform1i("u_pass",E).uniform2f("u_resolution",this.maxBristleCount,VERTICES_PER_BRISTLE).vertexAttribPointer(this.quadVertexBuffer,this.distanceConstraintProgram.getAttribLocation("a_position"),2,u.FLOAT,false,0,0);u.framebufferTexture2D(this.simulationFramebuffer,u.FRAMEBUFFER,u.COLOR_ATTACHMENT0,u.TEXTURE_2D,this.projectedPositionsTextureTemp,0);u.drawArrays(h,u.TRIANGLE_STRIP,0,4);Utilities.swap(this,"projectedPositionsTexture","projectedPositionsTextureTemp")}for(var E=0;E<3;++E){var h=u.createDrawState().bindFramebuffer(this.simulationFramebuffer).viewport(0,0,this._bristleCount,VERTICES_PER_BRISTLE).useProgram(this.bendingConstraintProgram).uniformTexture("u_positionsTexture",0,u.TEXTURE_2D,this.projectedPositionsTexture).uniformTexture("u_randomsTexture",1,u.TEXTURE_2D,this.randomsTexture).uniform1f("u_pointCount",VERTICES_PER_BRISTLE).uniform1f("u_stiffnessVariation",this.stiffnessVariation).uniform1i("u_pass",E).uniform2f("u_resolution",this.maxBristleCount,VERTICES_PER_BRISTLE).vertexAttribPointer(this.quadVertexBuffer,this.bendingConstraintProgram.getAttribLocation("a_position"),2,u.FLOAT,false,0,0);u.framebufferTexture2D(this.simulationFramebuffer,u.FRAMEBUFFER,u.COLOR_ATTACHMENT0,u.TEXTURE_2D,this.projectedPositionsTextureTemp,0);u.drawArrays(h,u.TRIANGLE_STRIP,0,4);Utilities.swap(this,"projectedPositionsTexture","projectedPositionsTextureTemp")}var h=u.createDrawState().bindFramebuffer(this.simulationFramebuffer).viewport(0,0,this._bristleCount,VERTICES_PER_BRISTLE).useProgram(this.planeConstraintProgram).uniformTexture("u_positionsTexture",0,u.TEXTURE_2D,this.projectedPositionsTexture).uniform2f("u_resolution",this.maxBristleCount,VERTICES_PER_BRISTLE).vertexAttribPointer(this.quadVertexBuffer,this.planeConstraintProgram.getAttribLocation("a_position"),2,u.FLOAT,false,0,0);u.framebufferTexture2D(this.simulationFramebuffer,u.FRAMEBUFFER,u.COLOR_ATTACHMENT0,u.TEXTURE_2D,this.projectedPositionsTextureTemp,0);u.drawArrays(h,u.TRIANGLE_STRIP,0,4);Utilities.swap(this,"projectedPositionsTexture","projectedPositionsTextureTemp")}var T=u.createDrawState().bindFramebuffer(this.simulationFramebuffer).viewport(0,0,this._bristleCount,VERTICES_PER_BRISTLE).useProgram(this.updateVelocityProgram).uniformTexture("u_positionsTexture",0,u.TEXTURE_2D,this.positionsTexture).uniformTexture("u_projectedPositionsTexture",1,u.TEXTURE_2D,this.projectedPositionsTexture).uniform2f("u_resolution",this.maxBristleCount,VERTICES_PER_BRISTLE).vertexAttribPointer(this.quadVertexBuffer,this.distanceConstraintProgram.getAttribLocation("a_position"),2,u.FLOAT,false,0,0);u.framebufferTexture2D(this.simulationFramebuffer,u.FRAMEBUFFER,u.COLOR_ATTACHMENT0,u.TEXTURE_2D,this.previousVelocitiesTexture,0);u.drawArrays(T,u.TRIANGLE_STRIP,0,4);Utilities.swap(this,"velocitiesTexture","previousVelocitiesTexture");Utilities.swap(this,"previousPositionsTexture","positionsTexture");Utilities.swap(this,"positionsTexture","projectedPositionsTexture")}}var WIDTH=240,HEIGHT=200,ALPHA_SLIDER_X=210,ALPHA_SLIDER_Y=5,ALPHA_SLIDER_WIDTH=20,ALPHA_SLIDER_HEIGHT=190,CIRCLE_X=100,CIRCLE_Y=100,INNER_RADIUS=77,OUTER_RADIUS=95,SQUARE_WIDTH=(INNER_RADIUS-5)*Math.sqrt(2);class ColorPicker{constructor(t,e,n){this._el=t;this._doc=$(document);this._debug=false;this._el.parent().on("mousedown",this.move);this.pickerProgram=n.createProgram(Shaders.Vertex.picker,Shaders.Fragment.picker,{a_position:0});this.quadVertexBuffer=n.createBuffer();n.bufferData(this.quadVertexBuffer,n.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,-1,1,1]),n.STATIC_DRAW);this.draw();if(this._debug){t.parent().addClass("debug")}}draw(){let t=STUDIO.wgl;let e=t.buildTexture(t.RGBA,t.UNSIGNED_BYTE,WIDTH,HEIGHT,null,t.CLAMP_TO_EDGE,t.CLAMP_TO_EDGE,t.NEAREST,t.NEAREST);let n=t.createFramebuffer();t.framebufferTexture2D(n,t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0);let r=STUDIO.painter.brushColorHSVA;let i=t.createDrawState().bindFramebuffer(n).viewport(0,0,WIDTH,HEIGHT).vertexAttribPointer(this.quadVertexBuffer,0,2,t.FLOAT,t.FALSE,0,0).useProgram(this.pickerProgram).uniform2f("u_resolution",WIDTH,HEIGHT).uniform1f("u_innerRadius",INNER_RADIUS).uniform1f("u_outerRadius",OUTER_RADIUS).uniform1f("u_squareWidth",SQUARE_WIDTH).uniform2f("u_circlePosition",CIRCLE_X,CIRCLE_Y).uniform2f("u_alphaSliderPosition",ALPHA_SLIDER_X,ALPHA_SLIDER_Y).uniform2f("u_alphaSliderDimensions",ALPHA_SLIDER_WIDTH,ALPHA_SLIDER_HEIGHT).uniform4f("u_currentHSVA",r[0],r[1],r[2],r[3]).uniform2f("u_screenResolution",WIDTH,HEIGHT).uniform2f("u_position",0,0).uniform2f("u_dimensions",WIDTH,HEIGHT);t.drawArrays(i,t.TRIANGLE_STRIP,0,4);let o=new Uint8Array(WIDTH*HEIGHT*4);t.readPixels(t.createReadState().bindFramebuffer(n),0,0,WIDTH,HEIGHT,t.RGBA,t.UNSIGNED_BYTE,o);t.deleteTexture(e);t.deleteFramebuffer(n);this._el.prop({width:WIDTH,height:HEIGHT});let s=this._el[0].getContext("2d"),a=s.createImageData(WIDTH,HEIGHT);a.data.set(o);s.putImageData(a,0,0)}move(t){let e=STUDIO.picker,n=e.drag,r,i;switch(t.type){case"mousedown":let o=$(t.target),s=o.prop("className"),a=o[0].parentNode.getBoundingClientRect(),u=STUDIO.painter,l=u.brushColorHSVA,_=180/Math.PI,c={x:0,y:0},E={x:0,y:0},h={y:t.clientY,x:t.clientX};o=o.parent();switch(s){case"picker-ring":r=t.offsetY-96;i=t.offsetX-96;h.deg=Math.round(Math.atan2(r,i)*_)+90;if(h.deg<0)h.deg+=360;h.y=a.top+111;h.x=a.left+111;break;case"picker-box":E.x=82;E.y=82;h.y-=t.offsetY;h.x-=t.offsetX;r=Math.min(Math.max(t.offsetY-10,c.y),E.y);i=Math.min(Math.max(t.offsetX-10,c.x),E.x);break;case"picker-alpha":E.y=170;h.y-=t.offsetY;r=Math.min(Math.max(t.offsetY-10,c.y),E.y);break;default:return}e.drag={el:o,min:c,max:E,_PI:_,type:s,hsva:l,click:h,painter:u,_min:Math.min,_max:Math.max,_round:Math.round,_atan2:Math.atan2};e.move({type:"mousemove",clientX:t.clientX,clientY:t.clientY});e._doc.on("mousemove mouseup",e.move);break;case"mousemove":let T={},f;switch(n.type){case"picker-ring":r=t.clientY-n.click.y;i=t.clientX-n.click.x;f=n._round(n._atan2(r,i)*n._PI)+90;T["--cp-hue"]=`${f}deg`;n.hsva[0]=(f+270)%360/360;break;case"picker-box":r=n._min(n._max(t.clientY-n.click.y-10,n.min.y),n.max.y);i=n._min(n._max(t.clientX-n.click.x-10,n.min.x),n.max.x);T["--cp-slY"]=`${r}px`;T["--cp-slX"]=`${i}px`;n.hsva[1]=i/n.max.x;n.hsva[2]=r/n.max.y;break;case"picker-alpha":r=n._min(n._max(t.clientY-n.click.y-10,n.min.y),n.max.y);T["--cp-alpha"]=`${r}px`;n.hsva[3]=r/n.max.y;break}if(e._debug)n.el.css(T);n.painter.brushColorHSVA=n.hsva;e.draw();break;case"mouseup":e._doc.off("mousemove mouseup",e.move);break}}}class Rectangle{constructor(t,e,n,r){this._left=t;this._bottom=e;this._width=n;this._height=r}get left(){return this._left}set left(t){this._left=t}get bottom(){return this._bottom}set bottom(t){this._bottom=t}get width(){return this._width}set width(t){this._width=t}get height(){return this._height}set height(t){this._height=t}get right(){return this._left+this._width}set right(t){this._width=t-this._left}get top(){return this._bottom+this._height}set top(t){this._height=t-this._bottom}clone(){return new Rectangle(this.left,this.bottom,this.width,this.height)}includeRectangle(t){var e=Math.max(this.right,t.right),n=Math.max(this.top,t.top);this._left=Math.min(this.left,t.left);this._bottom=Math.min(this.bottom,t.bottom);this.right=e;this.top=n;return this}intersectRectangle(t){var e=Math.min(this.right,t.right),n=Math.min(this.top,t.top);this._left=Math.max(this.left,t.left);this._bottom=Math.max(this.bottom,t.bottom);this.right=e;this.top=n;return this}translate(t,e){this._left+=t;this._bottom+=e;return this}scale(t,e){this._left*=t;this._bottom*=e;this._width*=t;this._height*=e;return this}round(){this._left=Math.round(this._left);this._bottom=Math.round(this._bottom);this._width=Math.round(this._width);this._height=Math.round(this._height)}getArea(){return this.width*this.height}}class State{constructor(t){this.wgl=t;this.changedParameters={}}setParameter(t,e){if(!arraysEqual(e,this.wgl.parameters[t].defaults)){this.changedParameters[t]=e}else{if(this.changedParameters.hasOwnProperty(t)){delete this.changedParameters[t]}}}clone(){var t=new this.constructor(this.wgl);for(var e in this.changedParameters){if(this.changedParameters.hasOwnProperty(e)){var n=this.changedParameters[e];var r=[];for(var i=0;i<n.length;++i){r.push(n[i])}t.changedParameters[e]=r}}return t}}class DrawState extends State{constructor(t){super(t,t);this.uniforms={}}bindFramebuffer(t){this.setParameter("framebuffer",[t]);return this}viewport(t,e,n,r){this.setParameter("viewport",[t,e,n,r]);return this}enable(t){if(t===this.wgl.DEPTH_TEST){this.setParameter("depthTest",[true])}else if(t===this.wgl.BLEND){this.setParameter("blend",[true])}else if(t===this.wgl.CULL_FACE){this.setParameter("cullFace",[true])}else if(t===this.wgl.POLYGON_OFFSET_FILL){this.setParameter("polygonOffsetFill",[true])}else if(t===this.wgl.SCISSOR_TEST){this.setParameter("scissorTest",[true])}return this}disable(t){if(t===this.wgl.DEPTH_TEST){this.setParameter("depthTest",[false])}else if(t===this.wgl.BLEND){this.setParameter("blend",[false])}else if(t===this.wgl.CULL_FACE){this.setParameter("cullFace",[false])}else if(t===this.wgl.POLYGON_OFFSET_FILL){this.setParameter("polygonOffsetFill",[false])}else if(t===this.wgl.SCISSOR_TEST){this.setParameter("scissorTest",[false])}return this}vertexAttribPointer(t,e,n,r,i,o,s){this.setParameter("attributeArray"+e.toString(),[t,n,r,i,o,s]);if(this.instancedExt&&this.changedParameters.hasOwnProperty("attributeDivisor"+e.toString())){this.setParameter("attributeDivisor"+e.toString(),[0])}return this}bindIndexBuffer(t){this.setParameter("indexBuffer",[t]);return this}depthFunc(t){this.setParameter("depthFunc",[t]);return this}frontFace(t){this.setParameter("frontFace",[t]);return this}blendEquation(t){this.blendEquationSeparate(t,t);return this}blendEquationSeparate(t,e){this.setParameter("blendEquation",[t,e]);return this}blendFunc(t,e){this.blendFuncSeparate(t,e,t,e);return this}blendFuncSeparate(t,e,n,r){this.setParameter("blendFunc",[t,e,n,r]);return this}scissor(t,e,n,r){this.setParameter("scissor",[t,e,n,r]);return this}useProgram(t){this.setParameter("program",[t]);return this}bindTexture(t,e,n){this.setParameter("texture"+t.toString(),[e,n]);return this}colorMask(t,e,n,r){this.setParameter("colorMask",[t,e,n,r]);return this}depthMask(t){this.setParameter("depthMask",[t]);return this}polygonOffset(t,e){this.setParameter("polygonOffset",[t,e]);return this}uniformTexture(t,e,n,r){this.uniform1i(t,e);this.bindTexture(e,n,r);return this}uniform1i(t,e){this.uniforms[t]={type:"1i",value:[e]};return this}uniform2i(t,e,n){this.uniforms[t]={type:"2i",value:[e,n]};return this}uniform3i(t,e,n,r){this.uniforms[t]={type:"3i",value:[e,n,r]};return this}uniform4i(t,e,n,r,i){this.uniforms[t]={type:"4i",value:[e,n,r,i]};return this}uniform1f(t,e){this.uniforms[t]={type:"1f",value:e};return this}uniform2f(t,e,n){this.uniforms[t]={type:"2f",value:[e,n]};return this}uniform3f(t,e,n,r){this.uniforms[t]={type:"3f",value:[e,n,r]};return this}uniform4f(t,e,n,r,i){this.uniforms[t]={type:"4f",value:[e,n,r,i]};return this}uniform1fv(t,e){this.uniforms[t]={type:"1fv",value:[e]};return this}uniform2fv(t,e){this.uniforms[t]={type:"2fv",value:[e]};return this}uniform3fv(t,e){this.uniforms[t]={type:"3fv",value:[e]};return this}uniform4fv(t,e){this.uniforms[t]={type:"4fv",value:[e]};return this}uniformMatrix2fv(t,e,n){this.uniforms[t]={type:"matrix2fv",value:[e,n]};return this}uniformMatrix3fv(t,e,n){this.uniforms[t]={type:"matrix3fv",value:[e,n]};return this}uniformMatrix4fv(t,e,n){this.uniforms[t]={type:"matrix4fv",value:[e,n]};return this}}class ClearState extends State{constructor(t){super(t,t)}bindFramebuffer(t){this.setParameter("framebuffer",[t]);return this}clearColor(t,e,n,r){console.log([t,e,n,r]);this.setParameter("clearColor",[t,e,n,r]);return this}clearDepth(t){this.setParameter("clearDepth",[t]);return this}colorMask(t,e,n,r){this.setParameter("colorMask",[t,e,n,r]);return this}depthMask(t){this.setParameter("depthMask",[t]);return this}enable(t){if(t===this.wgl.SCISSOR_TEST){this.setParameter("scissorTest",[true])}return this}disable(t){if(t===this.wgl.SCISSOR_TEST){this.setParameter("scissorTest",[false])}return this}scissor(t,e,n,r){this.setParameter("scissor",[t,e,n,r]);return this}}class ReadState extends State{constructor(t){super(t,t)}bindFramebuffer(t){this.setParameter("framebuffer",[t]);return this}}class WrappedProgram{constructor(t,e,n,r){this.uniformLocations={};this.uniforms={};let i=t.gl;let o=buildShader(i,i.VERTEX_SHADER,e),s=buildShader(i,i.FRAGMENT_SHADER,n);let a=this.program=i.createProgram();i.attachShader(a,o);i.attachShader(a,s);if(r!==undefined){for(let t in r){i.bindAttribLocation(a,r[t],t)}}i.linkProgram(a);this.attributeLocations={};let u=i.getProgramParameter(a,i.ACTIVE_ATTRIBUTES);for(let t=0;t<u;++t){let e=i.getActiveAttrib(a,t);let n=e.name;this.attributeLocations[n]=i.getAttribLocation(a,n)}let l=this.uniformLocations={};let _=i.getProgramParameter(a,i.ACTIVE_UNIFORMS);for(let t=0;t<_;t+=1){let e=i.getActiveUniform(a,t),n=i.getUniformLocation(a,e.name);l[e.name]=n}}getAttribLocation(t){return this.attributeLocations[t]}}var Utilities={swap:function(t,e,n){var r=t[e];t[e]=t[n];t[n]=r},clamp:function(t,e,n){return Math.max(e,Math.min(n,t))},getMousePosition:function(t,e){var n=e.getBoundingClientRect();return{x:t.clientX-n.left,y:t.clientY-n.top}},createCanvas(t,e){let n=$(document.createElement("canvas")),r=n[0].getContext("2d");n.prop({width:t,height:e});return{cvs:n,ctx:r}}};function keysInObject(t){var e=0;for(var n in t){if(t.hasOwnProperty(n)){e+=1}}return e}function buildShader(t,e,n){var r=t.createShader(e);t.shaderSource(r,n);t.compileShader(r);if(!t.getShaderParameter(r,t.COMPILE_STATUS)){console.log(t.getShaderInfoLog(r))}return r}function arraysEqual(t,e){for(var n=0;n<t.length;++n){if(t[n]!==e[n])return false}return true}function pascalRow(t){var e=[1];for(var n=0;n<t;++n){e.push(e[n]*(t-n)/(n+1))}return e}function hsvToRyb(t,e,n){t=t%1;var r=n*e,i=t*6,o=r*(1-Math.abs(i%2-1)),s=Math.floor(i),a=[r,o,0,0,o,r][s],u=[o,r,r,o,0,0][s],l=[0,0,o,r,r,o][s],_=n-r;a+=_;u+=_;l+=_;return[a,u,l]}function makeOrthographicMatrix(t,e,n,r,i,o,s){t[0]=2/(n-e);t[1]=0;t[2]=0;t[3]=0;t[4]=0;t[5]=2/(i-r);t[6]=0;t[7]=0;t[8]=0;t[9]=0;t[10]=-2/(s-o);t[11]=0;t[12]=-(n+e)/(n-e);t[13]=-(i+r)/(i-r);t[14]=-(s+o)/(s-o);t[15]=1;return t}function mix(t,e,n){return(1-n)*t+n*e}const Color={rgbToLightness(t,e,n){return 1/2*(Math.max(t,e,n)+Math.min(t,e,n))/255},rgbToSaturation(t,e,n){let r=this.rgbToLightness(t,e,n),i=Math.max(t,e,n),o=Math.min(t,e,n);return r===0||r===1?0:(i-o)/(1-Math.abs(2*r-1))/255},rgbToHue(t,e,n){let r=Math.round(Math.atan2(Math.sqrt(3)*(e-n),2*t-e-n)*180/Math.PI);return r<0?r+360:r},hslToRgb(t,e,n,r=1){let i=Math.round,o=Math.min,s=Math.max,a=e*o(n,1-n);let u=(e,r=(e+t/30)%12)=>n-a*s(o(r-3,9-r,1),-1);return[i(u(0)*255),i(u(8)*255),i(u(4)*255),r]},hslToHex(t,e,n,r=1){let i=this.hslToRgb(t,e,n,r);return this.rgbToHex(`rgba(${i.join(",")})`)},hexToHsl(t){let e=this.hexToRgb(t);return this.rgbToHsl(...e)},mixColors(t,e,n){let r=this.hexToRgb(t),i=this.hexToRgb(e),o=n*2-1,s=(o+1)/2,a=1-s,u=[parseInt(r[0]*s+i[0]*a,10),parseInt(r[1]*s+i[1]*a,10),parseInt(r[2]*s+i[2]*a,10),r[3]*s+i[3]*a];return this.rgbToHex(`rgba(${u.join(",")})`)},hexToHsv(t){let e=this.hexToRgb(t);return this.rgbToHsv(...e)},rgbToHsv(t,e,n,r=1){var i=Math.max(t,e,n),o=Math.min(t,e,n),s=i-o,a,u=i===0?0:s/i,l=i/255;switch(i){case o:a=0;break;case t:a=e-n+s*(e<n?6:0);a/=6*s;break;case e:a=n-t+s*2;a/=6*s;break;case n:a=t-e+s*4;a/=6*s;break}return[a,u,l,r]},hexToRgb(t){let e=parseInt(t.substr(1,2),16),n=parseInt(t.substr(3,2),16),r=parseInt(t.substr(5,2),16),i=parseInt(t.substr(7,2)||"ff",16)/255;return[e,n,r,i]},rgbToHsl(t,e,n,r=1){t/=255;e/=255;n/=255;var i=Math.max(t,e,n),o=Math.min(t,e,n),s=(i+o)/2,a,u;if(i==o){a=u=0}else{var l=i-o;u=s>.5?l/(2-i-o):l/(i+o);switch(i){case t:a=(e-n)/l+(e<n?6:0);break;case e:a=(n-t)/l+2;break;case n:a=(t-e)/l+4;break}a/=6}return[a,u,s,r]},rgbToHex(t){let e="0123456789abcdef".split(""),n=t=>isNaN(t)?"00":e[(t-t%16)/16]+e[t%16];t=t.match(/^rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\.\d]+)\)$/);if(!t)t=arguments[0].match(/^rgb?\((\d+),\s*(\d+),\s*(\d+)\)$/);let r=Math.round((t[4]||1)*255);return"#"+n(t[1])+n(t[2])+n(t[3])+n(r)}};