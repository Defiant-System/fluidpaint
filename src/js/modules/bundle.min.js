const Shaders = {
	Fragment: {
		advect: `precision highp float;

varying vec2 v_coordinates;

uniform sampler2D u_velocityTexture;
uniform sampler2D u_inputTexture;
uniform float u_deltaTime;
uniform float u_dissipation;
uniform vec2 u_resolution;
uniform vec2 u_min;
uniform vec2 u_max;

void main () {
	//RK2
	vec2 coordinates = gl_FragCoord.xy;
	vec2 velocity = texture2D(u_velocityTexture, coordinates / u_resolution).rg * 100.0;
	vec2 halfCoordinates = coordinates - velocity * 0.5 * u_deltaTime;
	vec2 halfVelocity = texture2D(u_velocityTexture, clamp(halfCoordinates, u_min, u_max) / u_resolution).rg * 100.0;
	vec2 finalCoordinates = coordinates - halfVelocity * u_deltaTime;

	gl_FragColor = texture2D(u_inputTexture, clamp(finalCoordinates, u_min, u_max) / u_resolution) * u_dissipation;
}
`,
		splat: `precision highp float;

#ifdef VELOCITY
varying vec2 v_previousVelocity;
varying vec2 v_velocity;
uniform float u_velocityScale;
#else
uniform vec4 u_splatColor;
#endif

uniform float u_splatRadius;

varying vec2 v_previousPosition;
varying vec2 v_position;

varying vec2 v_quadPosition;

varying vec2 v_coordinates;

float distanceToLine(vec2 a, vec2 b, vec2 p) {
	float dist = distance(a, b);
	vec2 direction = (b - a) / dist;

	float projectedDistance = dot(p - a, direction);
	projectedDistance = clamp(projectedDistance, 0.0, dist);

	vec2 projectedPosition = a + projectedDistance * direction;

	return distance(p, projectedPosition);
}

vec2 clampVelocity (vec2 vel) {
	float MAX_SPEED = 2.0;

	float speed = length(vel);

	if (speed > MAX_SPEED) {
		vel *= MAX_SPEED / speed;
	}
	
	return vel;
}

void main () {
	float splatDistance = distanceToLine(v_previousPosition, v_position, v_quadPosition);

	float multiplier = max(1.0 - splatDistance / u_splatRadius, 0.0);


	#ifdef VELOCITY
		vec2 velocity = mix(v_previousVelocity, v_velocity, v_coordinates.x * 0.5 + 0.5);
		gl_FragColor = vec4(clampVelocity(velocity * u_velocityScale), 0.0, multiplier);
	#else
		gl_FragColor = vec4(u_splatColor.rgb, u_splatColor.a * multiplier);
	#endif
}
`,
		divergence: `precision highp float;

varying vec2 v_coordinates;

uniform sampler2D u_velocityTexture;

uniform vec2 u_resolution;

void main () {
	vec2 coordinates = gl_FragCoord.xy / u_resolution;
	vec2 delta = 1.0 / u_resolution;

	vec2 left = texture2D(u_velocityTexture, coordinates + vec2(-delta.x, 0.0)).rg;
	vec2 right = texture2D(u_velocityTexture, coordinates + vec2(delta.x, 0.0)).rg;
	vec2 bottom = texture2D(u_velocityTexture, coordinates + vec2(0.0, -delta.y)).rg;
	vec2 top = texture2D(u_velocityTexture, coordinates + vec2(0.0, delta.y)).rg;

	float divergence = ((right.x - left.x) + (top.y - bottom.y)) / 2.0;

	gl_FragColor = vec4(divergence, 0.0, 0.0, 0.0);
}
`,
		jacobi: `precision highp float;

varying vec2 v_coordinates;

uniform vec2 u_resolution;

uniform sampler2D u_pressureTexture;
uniform sampler2D u_divergenceTexture;

void main () {
	vec2 coordinates = gl_FragCoord.xy / u_resolution;
	vec2 delta = 1.0 / u_resolution;

	float divergenceCenter = texture2D(u_divergenceTexture, coordinates).r;

	float center = texture2D(u_pressureTexture, coordinates).r;
	float left = texture2D(u_pressureTexture, coordinates + vec2(-delta.x, 0.0)).r;
	float right = texture2D(u_pressureTexture, coordinates + vec2(delta.x, 0.0)).r;
	float bottom = texture2D(u_pressureTexture, coordinates + vec2(0.0, -delta.y)).r;
	float top = texture2D(u_pressureTexture, coordinates + vec2(0.0, delta.y)).r;

	float newPressure = (left + right + bottom + top - divergenceCenter) / 4.0;

	gl_FragColor = vec4(newPressure, 0.0, 0.0, 0.0);
}
`,
		subtract: `precision highp float;

varying vec2 v_coordinates;

uniform vec2 u_resolution;

uniform sampler2D u_pressureTexture;
uniform sampler2D u_velocityTexture;

void main () {
	vec2 coordinates = gl_FragCoord.xy / u_resolution;
	vec2 delta = 1.0 / u_resolution;

	float center = texture2D(u_pressureTexture, coordinates).r;
	float left = texture2D(u_pressureTexture, coordinates + vec2(-delta.x, 0.0)).r;
	float right = texture2D(u_pressureTexture, coordinates + vec2(delta.x, 0.0)).r;
	float bottom = texture2D(u_pressureTexture, coordinates + vec2(0.0, -delta.y)).r;
	float top = texture2D(u_pressureTexture, coordinates + vec2(0.0, delta.y)).r;

	//compute gradient of pressure
	vec2 gradient = vec2(right - left, top - bottom) / 2.0;

	vec2 currentVelocity = texture2D(u_velocityTexture, coordinates).rg;

	vec2 newVelocity = currentVelocity - gradient;

	gl_FragColor = vec4(newVelocity, 0.0, 0.0);
}
`,
		resize: `precision highp float;

uniform sampler2D u_paintTexture;
uniform vec2 u_oldResolution;
uniform vec2 u_offset; //in texels
uniform float u_featherSize;

void main () {
	vec2 coordinates = (gl_FragCoord.xy - u_offset) / u_oldResolution;
	vec4 value = texture2D(u_paintTexture, coordinates);
	vec2 featherSize = u_featherSize / u_oldResolution;
	float scale = smoothstep(-featherSize.x, 0.0, coordinates.x) * smoothstep(-featherSize.y, 0.0, coordinates.y)
								* smoothstep(1.0 + featherSize.x, 1.0, coordinates.x) * smoothstep(1.0 + featherSize.y, 1.0, coordinates.y);

	gl_FragColor = value * scale;
}
`,
		project: `//advects brush positions forward in time

precision highp float;

uniform vec2 u_resolution;

uniform sampler2D u_positionsTexture; 
uniform sampler2D u_velocitiesTexture;
uniform sampler2D u_randomsTexture;

uniform float u_damping;
uniform float u_gravity;

uniform float u_verticesPerBristle;

float random (float n) {
	return fract(0.5 + n * (0.6180339887498949));
}

void main () {
	vec2 coordinates = gl_FragCoord.xy / u_resolution;

	vec3 position = texture2D(u_positionsTexture, coordinates).rgb;
	vec3 velocity = texture2D(u_velocitiesTexture, coordinates).rgb;

	velocity *= u_damping;

	velocity += vec3(0.0, 0.0, -u_gravity);

	gl_FragColor = vec4(position + velocity, 1.0);
}
`,
		brush: `precision highp float;

uniform vec4 u_color;

void main () {
	gl_FragColor = u_color;
}
`,
		painting: `precision highp float;

varying vec2 v_coordinates;
uniform sampler2D u_paintTexture;
uniform vec2 u_paintingSize; //painting size in pixels
uniform vec2 u_paintingPosition; //bottom left position in pixels
uniform vec2 u_paintingResolution;
uniform float u_normalScale;
uniform vec3 u_lightDirection;
uniform float u_roughness;
uniform float u_F0;
uniform float u_diffuseScale;
uniform float u_specularScale;

#ifdef RESIZING
uniform float u_featherSize;
#endif

//samples with feathering at the edges
vec4 samplePaintTexture (vec2 coordinates) {
	vec4 value = texture2D(u_paintTexture, coordinates);

	#ifdef RESIZING
		vec2 featherSize = u_featherSize / u_paintingResolution;
		float scale = smoothstep(-featherSize.x, 0.0, coordinates.x) * smoothstep(-featherSize.y, 0.0, coordinates.y)
					  * smoothstep(1.0 + featherSize.x, 1.0, coordinates.x) * smoothstep(1.0 + featherSize.y, 1.0, coordinates.y);
		return value * scale;
	#else
		return value;
	#endif
}


float getHeight (vec2 coordinates) {
	return samplePaintTexture(coordinates).a;
}


vec2 computeGradient(vec2 coordinates) { //sobel operator
	vec2 delta = 1.0 / u_paintingResolution;

	float topLeft = getHeight(coordinates + vec2(-delta.x, delta.y));
	float top = getHeight(coordinates + vec2(0.0, delta.y));
	float topRight = getHeight(coordinates + vec2(delta.x, delta.y));
	float left = getHeight(coordinates + vec2(-delta.x, 0.0));
	float right = getHeight(coordinates + vec2(delta.x, 0.0));
	float bottomLeft = getHeight(coordinates + vec2(-delta.x, -delta.y));
	float bottom = getHeight(coordinates + vec2(0.0, -delta.y));
	float bottomRight = getHeight(coordinates + vec2(delta.x, -delta.y));
	
	return vec2(
		 1.0 * topLeft - 1.0 * topRight + 2.0 * left - 2.0 * right + 1.0 * bottomLeft - 1.0 * bottomRight,
		-1.0 * topLeft + 1.0 * bottomLeft - 2.0 * top + 2.0 * bottom - 1.0 * topRight + 1.0 * bottomRight);
}


const float PI = 3.14159265;

float square (float x) {
	return x * x;
}

float fresnel (float F0, float lDotH) {
	float f = pow(1.0 - lDotH, 5.0);

	return (1.0 - F0) * f + F0;
}

float GGX (float alpha, float nDotH) {
	float a2 = square(alpha);

	return a2 / (PI * square(square(nDotH) * (a2 - 1.0) + 1.0));
}

float GGGX (float alpha, float nDotL, float nDotV) {
	float a2 = square(alpha);

	float gl = nDotL + sqrt(a2 + (1.0 - a2) * square(nDotL));
	float gv = nDotV + sqrt(a2 + (1.0 - a2) * square(nDotV));

	return 1.0 / (gl * gv);
}

float saturate (float x) {
	return clamp(x, 0.0, 1.0);
}

float specularBRDF (vec3 lightDirection, vec3 eyeDirection, vec3 normal, float roughness, float F0) {
	vec3 halfVector = normalize(lightDirection + eyeDirection);

	float nDotH = saturate(dot(normal, halfVector));
	float nDotL = saturate(dot(normal, lightDirection));
	float nDotV = saturate(dot(normal, eyeDirection));
	float lDotH = saturate(dot(lightDirection, halfVector));

	float D = GGX(roughness, nDotH);
	float G = GGGX(roughness, nDotL, nDotV);
	float F = fresnel(F0, lDotH);

	return D * G * F;
}

void main () {
	vec2 coordinates = (gl_FragCoord.xy - u_paintingPosition) / u_paintingSize;
	vec4 value = samplePaintTexture(coordinates); //r, g, b, height
	vec2 gradient = computeGradient(coordinates);
	vec3 normal = normalize(vec3(
		gradient.x,
		gradient.y,
		u_normalScale
	));

	vec3 lightDirection = normalize(u_lightDirection);
	vec3 eyeDirection = vec3(0.0, 0.0, 1.0);

	float diffuse = saturate(dot(lightDirection, normal));
	diffuse = diffuse * u_diffuseScale + (1.0 - u_diffuseScale);

	float specular = specularBRDF(lightDirection, eyeDirection, normal, u_roughness, u_F0);
	vec3 surfaceColor = value.rgb * diffuse + specular * u_specularScale;
	
	gl_FragColor = vec4(surfaceColor.rgb, value.a);
	// gl_FragColor = vec4(surfaceColor.rgb, 1.0);
}
`,
		copy: `(() => {throw "File not found: @import "../shaders/copy.frag"";})()`,
		output: `precision highp float;

varying vec2 v_coordinates;

uniform sampler2D u_input;

void main () {
	gl_FragColor = texture2D(u_input, v_coordinates);
#ifdef OUTPUT
	gl_FragColor.rgb *= gl_FragColor.a;
#endif
}
`,
		picker: `precision highp float;

varying vec2 v_coordinates; //in [-1, 1]

uniform vec4 u_currentHSVA;

uniform float u_innerRadius;
uniform float u_outerRadius;
uniform float u_squareWidth;

uniform vec2 u_circlePosition;

uniform vec2 u_alphaSliderPosition; //bottom left of alpha bar
uniform vec2 u_alphaSliderDimensions;

const float PI = 3.14159265;

vec3 trilinearInterpolate(vec3 p, vec3 v000, vec3 v100, vec3 v010, vec3 v001, vec3 v101, vec3 v011, vec3 v110, vec3 v111) {
	return v000 * (1.0 - p.x) * (1.0 - p.y) * (1.0 - p.z) +
		   v100 * p.x * (1.0 - p.y) * (1.0 - p.z) +
		   v010 * (1.0 - p.x) * p.y * (1.0 - p.z) +
		   v001 * (1.0 - p.x) * (1.0 - p.y) * p.z +
		   v101 * p.x * (1.0 - p.y) * p.z +
		   v011 * (1.0 - p.x) * p.y * p.z +
		   v110 * p.x * p.y * (1.0 - p.z) +
		   v111 * p.x * p.y * p.z;
}

vec3 rybToRgb(vec3 ryb) {
	#ifdef RGB
		return 1.0 - ryb.yxz;
	#endif
	return ryb;

	// return trilinearInterpolate(ryb, 
	// 	vec3(1.0, 1.0, 1.0), 
	// 	vec3(1.0, 0.0, 0.0), 
	// 	vec3(0.163, 0.373, 0.6), 
	// 	vec3(1.0, 1.0, 0.0), 
	// 	vec3(1.0, 0.5, 0.0), 
	// 	vec3(0.0, 0.66, 0.2),
	// 	vec3(0.5, 0.0, 0.5),
	// 	vec3(0.2, 0.094, 0.0));
}

vec3 hsv2ryb(vec3 c) {
	vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec3 hsvToRgb (vec3 hsv) {
	return rybToRgb(hsv2ryb(hsv));
}

float circleStrokeAlpha (vec2 position, vec2 center, float innerRadius, float outerRadius, float feather) {
	float dist = distance(center, position);
	return smoothstep(innerRadius - feather, innerRadius, dist) * smoothstep(outerRadius + feather, outerRadius, dist);
}

vec4 hueCircle () {
	vec2 coordinates = v_coordinates - u_circlePosition;

	float angle = atan(coordinates.y, coordinates.x) + 2.0 * PI;
	float hue = angle / (2.0 * PI);
	
	vec3 circleRGB = hsvToRgb(vec3(hue, 1.0, 1.0));

	float radius = length(coordinates);
	float circleAlpha = circleStrokeAlpha(coordinates, vec2(0.0, 0.0), u_innerRadius, u_outerRadius, 1.5);

	return vec4(circleRGB, circleAlpha);
}

float boxAlpha (vec2 position, vec2 bottomLeft, vec2 dimensions, vec2 feather) {
	vec2 center = bottomLeft + dimensions * 0.5;
	vec2 distances = max(abs(position - center) - dimensions * 0.5, vec2(0.0, 0.0));

	return smoothstep(feather.x, 0.0, distances.x) * smoothstep(feather.y, 0.0, distances.y);
}

float boxStrokeAlpha (vec2 position, vec2 bottomLeft, vec2 dimensions, vec2 strokeWidth, vec2 feather) {
	return boxAlpha(position, bottomLeft - strokeWidth * 0.5, dimensions + strokeWidth, feather) *
		   (1.0 - boxAlpha(position, bottomLeft + strokeWidth * 0.5, dimensions - strokeWidth, feather));
}

vec4 sbSquare () {
	vec2 coordinates = v_coordinates - u_circlePosition;

	float saturation = clamp((coordinates.x - (-u_squareWidth / 2.0)) / u_squareWidth, 0.0, 1.0);
	float lightness = clamp((coordinates.y - (-u_squareWidth / 2.0)) / u_squareWidth, 0.0, 1.0);

	vec3 squareRYB = hsv2ryb(vec3(u_currentHSVA.x, saturation, lightness));
	vec3 squareRGB = rybToRgb(squareRYB);

	float squareAlpha = boxAlpha(coordinates, vec2(-u_squareWidth * 0.5), vec2(u_squareWidth), vec2(1.0));

	return vec4(squareRGB, squareAlpha);
}


vec4 hueIndicator () {
	float hueIndicatorAngle = u_currentHSVA.x * PI * 2.0;

	vec2 coordinates = v_coordinates - u_circlePosition;
	float angle = atan(coordinates.y, coordinates.x);


	float relativeAngle = angle - hueIndicatorAngle; //angle relative to the hue indicator
	if (relativeAngle > PI) relativeAngle -= 2.0 * PI;
	if (relativeAngle < -PI) relativeAngle += 2.0 * PI;

	float indicatorWidth = 0.2;

	float radius = length(coordinates);

	float strokeWidth = 3.0;
	float strokeFeather = 1.5;

	float alpha = boxStrokeAlpha(vec2(radius, relativeAngle), vec2(u_innerRadius, -indicatorWidth * 0.5), vec2(u_outerRadius - u_innerRadius, indicatorWidth), vec2(strokeWidth, strokeWidth / u_innerRadius), vec2(strokeFeather, strokeFeather / u_innerRadius));

	return vec4(1.0, 1.0, 1.0, alpha);
}


vec4 sbIndicator () {
	float innerRadius = 8.0;

	vec2 indicatorPosition = vec2(
		u_circlePosition.x - u_squareWidth * 0.5 + innerRadius + u_currentHSVA.y * (u_squareWidth - innerRadius * 2.0),
		u_circlePosition.y - u_squareWidth * 0.5 + innerRadius + u_currentHSVA.z * (u_squareWidth - innerRadius * 2.0));

	float alpha = circleStrokeAlpha(v_coordinates, indicatorPosition, innerRadius, innerRadius + 2.0, 1.5);

	return vec4(1.0, 1.0, 1.0, alpha);
}



vec4 alphaSlider () {
	float feather = 0.75;
	float alpha = smoothstep(u_alphaSliderPosition.x - feather, u_alphaSliderPosition.x, v_coordinates.x) *
					smoothstep(u_alphaSliderPosition.x + u_alphaSliderDimensions.x + feather, u_alphaSliderPosition.x + u_alphaSliderDimensions.x, v_coordinates.x) *
					smoothstep(u_alphaSliderPosition.y - feather, u_alphaSliderPosition.y, v_coordinates.y) *
					smoothstep(u_alphaSliderPosition.y + u_alphaSliderDimensions.y + feather, u_alphaSliderPosition.y + u_alphaSliderDimensions.y, v_coordinates.y);

	float t = (v_coordinates.y - u_alphaSliderPosition.y) / u_alphaSliderDimensions.y;

	vec2 coordinates = v_coordinates - u_alphaSliderPosition;
	coordinates = floor(coordinates / 5.0);
	float checkerboard = mod(coordinates.x + mod(coordinates.y, 2.0), 2.0) * 0.05 + 0.95;

	vec3 color = mix(vec3(checkerboard), hsvToRgb(u_currentHSVA.rgb), (v_coordinates.y - u_alphaSliderPosition.y) / u_alphaSliderDimensions.y);

	return vec4(color, alpha);
}

vec4 alphaIndicator () {
	float indicatorHeight = 15.0;
	float indicatorY = u_alphaSliderPosition.y + u_currentHSVA.a * (u_alphaSliderDimensions.y - indicatorHeight);

	float strokeWidth = 3.0;
	float strokeFeather = 1.5;
	float alpha = boxStrokeAlpha(v_coordinates, vec2(u_alphaSliderPosition.x, indicatorY), vec2(u_alphaSliderDimensions.x, indicatorHeight), vec2(strokeWidth), vec2(strokeFeather));

	return vec4(1.0, 1.0, 1.0, alpha);
}

vec4 alphaBlend (vec4 color, vec4 source) {
	vec4 result = vec4(0.0);
	result.rgb = source.a * source.rgb + (1.0 - source.a) * color.rgb;
	result.a = 1.0 * source.a + (1.0 - source.a) * color.a;

	return result;
}

void main () {
	vec4 color = vec4(0.0, 0.0, 0.0, 0.0);

	vec4 sbSquareColor = sbSquare();
	color = alphaBlend(color, sbSquareColor);
	
	vec4 sbIndicatorColor = sbIndicator();
	color = alphaBlend(color, sbIndicatorColor);

	vec4 hueCircleColor = hueCircle();
	color = alphaBlend(color, hueCircleColor);

	vec4 hueIndicatorColor = hueIndicator();
	color = alphaBlend(color, hueIndicatorColor);

	vec4 alphaSliderColor = alphaSlider();
	color = alphaBlend(color, alphaSliderColor);

	vec4 alphaIndicatorColor = alphaIndicator();
	color = alphaBlend(color, alphaIndicatorColor);

	gl_FragColor = color;
}
`,
		setbristles: `precision highp float;

uniform vec3 u_brushPosition;
uniform float u_brushScale;
uniform float u_bristleCount;

uniform float u_bristleLength; //length of total bristle
uniform float u_verticesPerBristle;

uniform sampler2D u_randomsTexture;
uniform vec2 u_resolution;

uniform float u_jitter;

const float PHI = 1.618033988749895;
const float PI = 3.14159265;

void main () {
	vec2 coordinates = gl_FragCoord.xy / u_resolution;

	vec4 randoms = texture2D(u_randomsTexture, coordinates);

	float bristleIndex = floor(gl_FragCoord.x); //which bristle
	float vertexIndex = floor(gl_FragCoord.y);

	//jittered sunflower distribution

	float theta = (bristleIndex + (randoms.z - 0.5) * u_jitter) * 2.0 * PI / (PHI * PHI);
	float r = sqrt(bristleIndex + (randoms.w - 0.5) * u_jitter) / sqrt(u_bristleCount);

	float spacing = u_bristleLength / (u_verticesPerBristle - 1.0);
	vec3 brushSpaceBristlePosition = vec3(r * cos(theta), r * sin(theta), -vertexIndex * spacing);

	vec3 bristlePosition = u_brushPosition + brushSpaceBristlePosition * u_brushScale;

	gl_FragColor = vec4(bristlePosition, 1.0);
}
`,
		updatevelocity: `//updates velocity with projectedPosition - position

precision highp float;

uniform vec2 u_resolution;

uniform sampler2D u_positionsTexture; 
uniform sampler2D u_projectedPositionsTexture;

void main () {
	vec2 coordinates = gl_FragCoord.xy / u_resolution;

	vec3 velocity = texture2D(u_projectedPositionsTexture, coordinates).rgb - texture2D(u_positionsTexture, coordinates).rgb;

	gl_FragColor = vec4(velocity, 1.0);
}
`,
		planeconstraint: `precision highp float;

uniform vec2 u_resolution;

uniform sampler2D u_positionsTexture;

void main () {
	vec2 coordinates = gl_FragCoord.xy / u_resolution;

	vec3 position = texture2D(u_positionsTexture, coordinates).rgb;

	if (position.z < 0.0) position.z *= 0.5;

	gl_FragColor = vec4(position, 1.0);

}
`,
		bendingconstraint: `precision highp float;

uniform vec2 u_resolution;
uniform sampler2D u_positionsTexture;
uniform sampler2D u_randomsTexture;
uniform float u_pointCount;
uniform int u_pass; //0, 1 or 2, 0 means we do 0-1-2, 3-4-5, 6-7-8, 1 means we do 1-2-3, 4-5-6, 7-8-9, 2 means we do 2-3-4, 5-6-7, 8-9-10
uniform float u_stiffnessVariation;

float length2(vec3 v) {
	return v.x * v.x + v.y * v.y + v.z * v.z;
}

void main () {
	vec2 coordinates = gl_FragCoord.xy / u_resolution;

	float index = gl_FragCoord.y;
	float baseIndex = floor((index - float(u_pass)) / 3.0) * 3.0 + float(u_pass); //the base index of this a, b, c pair

	index = floor(index);

	if (baseIndex >= 0.0 && baseIndex < u_pointCount - 2.0) {
		float aIndex = baseIndex;
		float bIndex = baseIndex + 1.0;
		float cIndex = baseIndex + 2.0;

		vec3 aPos = texture2D(u_positionsTexture, vec2(coordinates.x, (aIndex + 0.5) / u_pointCount)).rgb;
		float aW = 1.0;
		if (aIndex < 0.1) aW = 0.0;

		vec3 bPos = texture2D(u_positionsTexture, vec2(coordinates.x, (bIndex + 0.5) / u_pointCount)).rgb;
		float bW = 1.0;

		vec3 cPos = texture2D(u_positionsTexture, vec2(coordinates.x, (cIndex + 0.5) / u_pointCount)).rgb;
		float cW = 1.0;

		vec3 r1 = (bPos - aPos) / distance(aPos, bPos);
		vec3 r2 = (cPos - bPos) / distance(bPos, cPos);

		float constraint = dot(r1, r2) - 1.0;
		float random = texture2D(u_randomsTexture, vec2(coordinates.x, 0.5 / u_pointCount)).g;
		float stiffness = random * u_stiffnessVariation;

		if (constraint > -1.0) {
			vec3 gradA = (dot(r1, r2) * r1 - r2) / max(distance(aPos, bPos), 0.0001);
			vec3 gradC = (-dot(r1, r2) * r2 + r1) / max(distance(bPos, cPos), 0.0001);
			vec3 gradB = -gradA - gradC;

			float s = stiffness * constraint / max(aW * length2(gradA) + bW * length2(gradB) + cW * length2(gradC), 0.0001);
			vec3 newPosition;
			if (index == aIndex) {
				vec3 currentPosition = aPos;
				newPosition = currentPosition - s * gradA * aW;
			} else if (index == bIndex) {
				vec3 currentPosition = bPos;
				newPosition = currentPosition - s * gradB * bW;
			} else if (index == cIndex) {
				vec3 currentPosition = cPos;
				newPosition = currentPosition - s * gradC * cW;
			}

			gl_FragColor = vec4(newPosition, 0.0);
		} else {
			gl_FragColor = texture2D(u_positionsTexture, coordinates).rgba;
		}
	} else {
		gl_FragColor = texture2D(u_positionsTexture, coordinates).rgba;
	}
}
`,
		distanceconstraint: `precision highp float;

uniform int u_pass; //0 or 1, in pass 0 we do 0-1, 2-3, 4-5..., in pass 1 we do 1-2, 3-4, 5-6...

uniform vec2 u_resolution;

uniform sampler2D u_positionsTexture;
uniform float u_pointCount;

uniform float u_targetDistance;

void main () {
	vec2 coordinates = gl_FragCoord.xy / u_resolution;

	float index = floor(gl_FragCoord.y); //which vertex on the bristle

	float myWeight = 1.0;
	if (index < 0.1) myWeight = 0.0;

	vec3 myPosition = texture2D(u_positionsTexture, vec2(coordinates.x, (index + 0.5) / u_pointCount)).rgb;

	float otherIndex = 0.0;

	if (mod(index, 2.0) < 0.01) {
		if (u_pass == 0) {
			otherIndex = index + 1.0;
		} else {
			otherIndex = index - 1.0;
		}
	} else {
		if (u_pass == 0) {
			otherIndex = index - 1.0;
		} else {
			otherIndex = index + 1.0;
		}
	}

	float otherWeight = 1.0;
	if (otherIndex < 0.1) otherWeight = 0.0;

	vec3 newPosition = myPosition;

	if (otherIndex >= 0.0 && otherIndex < u_pointCount) {
		vec3 otherPosition = texture2D(u_positionsTexture, vec2(coordinates.x, (otherIndex + 0.5) / u_pointCount)).rgb;

		float currentDistance = distance(myPosition, otherPosition);
		vec3 towards = (otherPosition - myPosition) / max(currentDistance, 0.01);

		newPosition = myPosition + (myWeight / (myWeight + otherWeight)) * (currentDistance - u_targetDistance) * towards;
	} 

	gl_FragColor = vec4(newPosition, 1.0);

}
`,
	},
	Vertex: {
		splat: `precision highp float;

attribute vec4 a_splatCoordinates; //(texCoord.x, texCoord.y, quad x (-1 or 1), quad y (-1 or 1))

uniform vec2 u_paintingDimensions;
uniform vec2 u_paintingPosition;
uniform float u_splatRadius;
uniform float u_zThreshold;

uniform sampler2D u_positionsTexture;
uniform sampler2D u_previousPositionsTexture;

varying vec2 v_coordinates; //in [-1, 1]

varying vec2 v_previousPosition;
varying vec2 v_position;

varying vec2 v_quadPosition;

#ifdef VELOCITY
	uniform sampler2D u_velocitiesTexture;
	uniform sampler2D u_previousVelocitiesTexture;

	varying vec2 v_velocity;
	varying vec2 v_previousVelocity;
#endif

void main () {
	vec2 coordinates = a_splatCoordinates.zw; //in [-1, 1]

	vec3 position = texture2D(u_positionsTexture, a_splatCoordinates.xy).rgb;
	vec3 previousPosition = texture2D(u_previousPositionsTexture, a_splatCoordinates.xy).rgb;

	if (position.z > u_zThreshold) {
		position = vec3(100000000.0, 1000000.0, 100000000.0);
		previousPosition = vec3(100000000.0, 1000000.0, 100000000.0);
	}

	vec2 planarPosition = position.xy;
	vec2 previousPlanarPosition = previousPosition.xy;

	vec2 mid = (planarPosition + previousPlanarPosition) * 0.5;
	

	float dist = distance(previousPlanarPosition.xy, planarPosition.xy);
	vec2 direction = (planarPosition - previousPlanarPosition) / dist;
	vec2 tangent = vec2(-direction.y, direction.x);


	vec2 finalPosition = mid + coordinates.x * direction * (dist * 0.5 + u_splatRadius) + coordinates.y * tangent * u_splatRadius;

	//finalPosition = mid + coordinates * u_splatRadius;
   

	v_previousPosition = previousPlanarPosition;
	v_position = planarPosition;
	v_quadPosition = finalPosition;


	v_coordinates = a_splatCoordinates.zw;

	gl_Position = vec4(-1.0 + 2.0 * (finalPosition - u_paintingPosition) / u_paintingDimensions, 0.0, 1.0);
	
#ifdef VELOCITY
	vec3 velocity = texture2D(u_velocitiesTexture, a_splatCoordinates.xy).rgb;
	vec3 previousVelocity = texture2D(u_previousVelocitiesTexture, a_splatCoordinates.xy).rgb;

	v_velocity = velocity.xy;
	v_previousVelocity = previousVelocity.xy;
#endif

}
`,
		brush: `precision highp float;

uniform vec2 u_canvasDimensions;

uniform mat4 u_projectionViewMatrix;

attribute vec2 a_textureCoordinates; //coordinates of this vertex into the brush texture

uniform sampler2D u_positionsTexture;

void main () {
	vec3 position = texture2D(u_positionsTexture, a_textureCoordinates).rgb;

	vec4 outPos = u_projectionViewMatrix * vec4(position, 1.0);
	outPos.z = 0.0;

	gl_Position = outPos;
}
`,
		picker: `precision highp float;

attribute vec2 a_position;

varying vec2 v_coordinates; //in ([0, width], [0, height])

uniform vec2 u_resolution;

uniform vec2 u_screenResolution;
uniform vec2 u_position;
uniform vec2 u_dimensions;

void main () {
	v_coordinates = (a_position * 0.5 + 0.5) * u_resolution;

	vec2 screenPosition = u_position + (a_position * 0.5 + 0.5) * u_dimensions;

	gl_Position = vec4((screenPosition / u_screenResolution) * 2.0 - 1.0, 0.0, 1.0);
}
`,
		painting: `precision highp float;

attribute vec2 a_position;

varying vec2 v_coordinates;

void main () {
	v_coordinates = a_position * 0.5 + 0.5;

	gl_Position = vec4(a_position, 0.0, 1.0);
}
`,
		fullscreen: `precision highp float;

attribute vec2 a_position;

varying vec2 v_coordinates;

void main () {
	v_coordinates = a_position * 0.5 + 0.5;

	gl_Position = vec4(a_position, 0.0, 1.0);
}
`,
	}
};

let QUALITIES = [
		{ name: "Low", resolutionScale: 1.0 },
		{ name: "Medium", resolutionScale: 1.5 },
		{ name: "High", resolutionScale: 2.0 }
	],
	InteractionMode = {
		NONE: 0,
		PAINTING: 1,
		RESIZING: 2,
		PANNING: 3
	},
	INITIAL_QUALITY = 0,
	MIN_PAINTING_WIDTH = 300,
	MAX_PAINTING_WIDTH = 4096, //this is further constrained by the maximum texture size
	RESIZING_RADIUS = 20,
	RESIZING_FEATHER_SIZE = 8, //in pixels 
	//rendering parameters
	NORMAL_SCALE = 7.0,
	ROUGHNESS = 0.075,
	F0 = 0.05,
	SPECULAR_SCALE = 0.5,
	DIFFUSE_SCALE = 0.15,
	LIGHT_DIRECTION = [0, 1, 1],
	HISTORY_SIZE = 4; //number of snapshots we store - this should be number of reversible actions + 1

// Brush parameters
let N_PREVIOUS_SPEEDS = 15, // how many previous speeds we store
	//for thin brush (fewest bristles)
	THIN_MIN_ALPHA = 0.002,
	THIN_MAX_ALPHA = 0.08,
	//for thick brush (most bristles)
	THICK_MIN_ALPHA = 0.002,
	THICK_MAX_ALPHA = 0.025,
	MAX_BRISTLE_COUNT = 100,
	MIN_BRISTLE_COUNT = 10,
	MIN_BRUSH_SCALE = 5,
	MAX_BRUSH_SCALE = 75,
	Z_THRESHOLD = 0.13333, // this is scaled with the brushScale
	VERTICES_PER_BRISTLE = 10,
	BRISTLE_LENGTH = 4.5, // relative to a scale of 1
	BRISTLE_JITTER = 0.5,
	ITERATIONS = 20;

// Simulator variables
let PRESSURE_JACOBI_ITERATIONS = 2,
	FRAMES_TO_SIMULATE = 60, // how many frames to simulate the area induced by each splat for
	//splatting parameters
	SPLAT_PADDING = 4.5, // approximately sqrt(BRISTLE_LENGTH * BRISTLE_LENGTH - BRUSH_HEIGHT * BRUSH_HEIGHT)
	SPEED_PADDING = 1.1;


let CONSTANT_NAMES = [
	"ACTIVE_ATTRIBUTES",
	"ACTIVE_ATTRIBUTE_MAX_LENGTH",
	"ACTIVE_TEXTURE",
	"ACTIVE_UNIFORMS",
	"ACTIVE_UNIFORM_MAX_LENGTH",
	"ALIASED_LINE_WIDTH_RANGE",
	"ALIASED_POINT_SIZE_RANGE",
	"ALPHA",
	"ALPHA_BITS",
	"ALWAYS",
	"ARRAY_BUFFER",
	"ARRAY_BUFFER_BINDING",
	"ATTACHED_SHADERS",
	"BACK",
	"BLEND",
	"BLEND_COLOR",
	"BLEND_DST_ALPHA",
	"BLEND_DST_RGB",
	"BLEND_EQUATION",
	"BLEND_EQUATION_ALPHA",
	"BLEND_EQUATION_RGB",
	"BLEND_SRC_ALPHA",
	"BLEND_SRC_RGB",
	"BLUE_BITS",
	"BOOL",
	"BOOL_VEC2",
	"BOOL_VEC3",
	"BOOL_VEC4",
	"BROWSER_DEFAULT_WEBGL",
	"BUFFER_SIZE",
	"BUFFER_USAGE",
	"BYTE",
	"CCW",
	"CLAMP_TO_EDGE",
	"COLOR_ATTACHMENT0",
	"COLOR_BUFFER_BIT",
	"COLOR_CLEAR_VALUE",
	"COLOR_WRITEMASK",
	"COMPILE_STATUS",
	"COMPRESSED_TEXTURE_FORMATS",
	"CONSTANT_ALPHA",
	"CONSTANT_COLOR",
	"CONTEXT_LOST_WEBGL",
	"CULL_FACE",
	"CULL_FACE_MODE",
	"CURRENT_PROGRAM",
	"CURRENT_VERTEX_ATTRIB",
	"CW",
	"DECR",
	"DECR_WRAP",
	"DELETE_STATUS",
	"DEPTH_ATTACHMENT",
	"DEPTH_BITS",
	"DEPTH_BUFFER_BIT",
	"DEPTH_CLEAR_VALUE",
	"DEPTH_COMPONENT",
	"DEPTH_COMPONENT16",
	"DEPTH_FUNC",
	"DEPTH_RANGE",
	"DEPTH_STENCIL",
	"DEPTH_STENCIL_ATTACHMENT",
	"DEPTH_TEST",
	"DEPTH_WRITEMASK",
	"DITHER",
	"DONT_CARE",
	"DST_ALPHA",
	"DST_COLOR",
	"DYNAMIC_DRAW",
	"ELEMENT_ARRAY_BUFFER",
	"ELEMENT_ARRAY_BUFFER_BINDING",
	"EQUAL",
	"FASTEST",
	"FLOAT",
	"FLOAT_MAT2",
	"FLOAT_MAT3",
	"FLOAT_MAT4",
	"FLOAT_VEC2",
	"FLOAT_VEC3",
	"FLOAT_VEC4",
	"FRAGMENT_SHADER",
	"FRAMEBUFFER",
	"FRAMEBUFFER_ATTACHMENT_OBJECT_NAME",
	"FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE",
	"FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE",
	"FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL",
	"FRAMEBUFFER_BINDING",
	"FRAMEBUFFER_COMPLETE",
	"FRAMEBUFFER_INCOMPLETE_ATTACHMENT",
	"FRAMEBUFFER_INCOMPLETE_DIMENSIONS",
	"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT",
	"FRAMEBUFFER_UNSUPPORTED",
	"FRONT",
	"FRONT_AND_BACK",
	"FRONT_FACE",
	"FUNC_ADD",
	"FUNC_REVERSE_SUBTRACT",
	"FUNC_SUBTRACT",
	"GENERATE_MIPMAP_HINT",
	"GEQUAL",
	"GREATER",
	"GREEN_BITS",
	"HIGH_FLOAT",
	"HIGH_INT",
	"INCR",
	"INCR_WRAP",
	"INFO_LOG_LENGTH",
	"INT",
	"INT_VEC2",
	"INT_VEC3",
	"INT_VEC4",
	"INVALID_ENUM",
	"INVALID_FRAMEBUFFER_OPERATION",
	"INVALID_OPERATION",
	"INVALID_VALUE",
	"INVERT",
	"KEEP",
	"LEQUAL",
	"LESS",
	"LINEAR",
	"LINEAR_MIPMAP_LINEAR",
	"LINEAR_MIPMAP_NEAREST",
	"LINES",
	"LINE_LOOP",
	"LINE_STRIP",
	"LINE_WIDTH",
	"LINK_STATUS",
	"LOW_FLOAT",
	"LOW_INT",
	"LUMINANCE",
	"LUMINANCE_ALPHA",
	"MAX_COMBINED_TEXTURE_IMAGE_UNITS",
	"MAX_CUBE_MAP_TEXTURE_SIZE",
	"MAX_FRAGMENT_UNIFORM_VECTORS",
	"MAX_RENDERBUFFER_SIZE",
	"MAX_TEXTURE_IMAGE_UNITS",
	"MAX_TEXTURE_SIZE",
	"MAX_VARYING_VECTORS",
	"MAX_VERTEX_ATTRIBS",
	"MAX_VERTEX_TEXTURE_IMAGE_UNITS",
	"MAX_VERTEX_UNIFORM_VECTORS",
	"MAX_VIEWPORT_DIMS",
	"MEDIUM_FLOAT",
	"MEDIUM_INT",
	"MIRRORED_REPEAT",
	"NEAREST",
	"NEAREST_MIPMAP_LINEAR",
	"NEAREST_MIPMAP_NEAREST",
	"NEVER",
	"NICEST",
	"NONE",
	"NOTEQUAL",
	"NO_ERROR",
	"NUM_COMPRESSED_TEXTURE_FORMATS",
	"ONE",
	"ONE_MINUS_CONSTANT_ALPHA",
	"ONE_MINUS_CONSTANT_COLOR",
	"ONE_MINUS_DST_ALPHA",
	"ONE_MINUS_DST_COLOR",
	"ONE_MINUS_SRC_ALPHA",
	"ONE_MINUS_SRC_COLOR",
	"OUT_OF_MEMORY",
	"PACK_ALIGNMENT",
	"POINTS",
	"POLYGON_OFFSET_FACTOR",
	"POLYGON_OFFSET_FILL",
	"POLYGON_OFFSET_UNITS",
	"RED_BITS",
	"RENDERBUFFER",
	"RENDERBUFFER_ALPHA_SIZE",
	"RENDERBUFFER_BINDING",
	"RENDERBUFFER_BLUE_SIZE",
	"RENDERBUFFER_DEPTH_SIZE",
	"RENDERBUFFER_GREEN_SIZE",
	"RENDERBUFFER_HEIGHT",
	"RENDERBUFFER_INTERNAL_FORMAT",
	"RENDERBUFFER_RED_SIZE",
	"RENDERBUFFER_STENCIL_SIZE",
	"RENDERBUFFER_WIDTH",
	"RENDERER",
	"REPEAT",
	"REPLACE",
	"RGB",
	"RGB5_A1",
	"RGB565",
	"RGBA",
	"RGBA4",
	"SAMPLER_2D",
	"SAMPLER_CUBE",
	"SAMPLES",
	"SAMPLE_ALPHA_TO_COVERAGE",
	"SAMPLE_BUFFERS",
	"SAMPLE_COVERAGE",
	"SAMPLE_COVERAGE_INVERT",
	"SAMPLE_COVERAGE_VALUE",
	"SCISSOR_BOX",
	"SCISSOR_TEST",
	"SHADER_COMPILER",
	"SHADER_SOURCE_LENGTH",
	"SHADER_TYPE",
	"SHADING_LANGUAGE_VERSION",
	"SHORT",
	"SRC_ALPHA",
	"SRC_ALPHA_SATURATE",
	"SRC_COLOR",
	"STATIC_DRAW",
	"STENCIL_ATTACHMENT",
	"STENCIL_BACK_FAIL",
	"STENCIL_BACK_FUNC",
	"STENCIL_BACK_PASS_DEPTH_FAIL",
	"STENCIL_BACK_PASS_DEPTH_PASS",
	"STENCIL_BACK_REF",
	"STENCIL_BACK_VALUE_MASK",
	"STENCIL_BACK_WRITEMASK",
	"STENCIL_BITS",
	"STENCIL_BUFFER_BIT",
	"STENCIL_CLEAR_VALUE",
	"STENCIL_FAIL",
	"STENCIL_FUNC",
	"STENCIL_INDEX",
	"STENCIL_INDEX8",
	"STENCIL_PASS_DEPTH_FAIL",
	"STENCIL_PASS_DEPTH_PASS",
	"STENCIL_REF",
	"STENCIL_TEST",
	"STENCIL_VALUE_MASK",
	"STENCIL_WRITEMASK",
	"STREAM_DRAW",
	"SUBPIXEL_BITS",
	"TEXTURE",
	"TEXTURE0",
	"TEXTURE1",
	"TEXTURE2",
	"TEXTURE3",
	"TEXTURE4",
	"TEXTURE5",
	"TEXTURE6",
	"TEXTURE7",
	"TEXTURE8",
	"TEXTURE9",
	"TEXTURE10",
	"TEXTURE11",
	"TEXTURE12",
	"TEXTURE13",
	"TEXTURE14",
	"TEXTURE15",
	"TEXTURE16",
	"TEXTURE17",
	"TEXTURE18",
	"TEXTURE19",
	"TEXTURE20",
	"TEXTURE21",
	"TEXTURE22",
	"TEXTURE23",
	"TEXTURE24",
	"TEXTURE25",
	"TEXTURE26",
	"TEXTURE27",
	"TEXTURE28",
	"TEXTURE29",
	"TEXTURE30",
	"TEXTURE31",
	"TEXTURE_2D",
	"TEXTURE_BINDING_2D",
	"TEXTURE_BINDING_CUBE_MAP",
	"TEXTURE_CUBE_MAP",
	"TEXTURE_CUBE_MAP_NEGATIVE_X",
	"TEXTURE_CUBE_MAP_NEGATIVE_Y",
	"TEXTURE_CUBE_MAP_NEGATIVE_Z",
	"TEXTURE_CUBE_MAP_POSITIVE_X",
	"TEXTURE_CUBE_MAP_POSITIVE_Y",
	"TEXTURE_CUBE_MAP_POSITIVE_Z",
	"TEXTURE_MAG_FILTER",
	"TEXTURE_MIN_FILTER",
	"TEXTURE_WRAP_S",
	"TEXTURE_WRAP_T",
	"TRIANGLES",
	"TRIANGLE_FAN",
	"TRIANGLE_STRIP",
	"UNPACK_ALIGNMENT",
	"UNPACK_COLORSPACE_CONVERSION_WEBGL",
	"UNPACK_FLIP_Y_WEBGL",
	"UNPACK_PREMULTIPLY_ALPHA_WEBGL",
	"UNSIGNED_BYTE",
	"UNSIGNED_INT",
	"UNSIGNED_SHORT",
	"UNSIGNED_SHORT_4_4_4_4",
	"UNSIGNED_SHORT_5_5_5_1",
	"UNSIGNED_SHORT_5_6_5",
	"VALIDATE_STATUS",
	"VENDOR",
	"VERSION",
	"VERTEX_ATTRIB_ARRAY_BUFFER_BINDING",
	"VERTEX_ATTRIB_ARRAY_ENABLED",
	"VERTEX_ATTRIB_ARRAY_NORMALIZED",
	"VERTEX_ATTRIB_ARRAY_POINTER",
	"VERTEX_ATTRIB_ARRAY_SIZE",
	"VERTEX_ATTRIB_ARRAY_STRIDE",
	"VERTEX_ATTRIB_ARRAY_TYPE",
	"VERTEX_SHADER",
	"VIEWPORT",
	"ZERO"
];


class SplatArea {
	constructor(rectangle, frameNumber) {
		this.rectangle = rectangle;
		this.frameNumber = frameNumber;
	}
}


class Snapshot {
	constructor(texture, paintingWidth, paintingHeight, resolutionScale) {
		this.texture = texture;
		this.paintingWidth = paintingWidth;
		this.paintingHeight = paintingHeight;
		this.resolutionScale = resolutionScale;
	}

	get textureWidth() {
		return Math.ceil(this.paintingWidth * this.resolutionScale);
	}

	get textureHeight() {
		return Math.ceil(this.paintingHeight * this.resolutionScale);
	}
}


class Brush {
	constructor(wgl, initialCount, maxBristleCount) {
		this.wgl = wgl;
		this.stiffnessVariation = 0.3;
		this.brushDamping = 0.15;
		this.gravity = 30;

		this.maxBristleCount = maxBristleCount;
		this._bristleCount = initialCount; // number of bristles currently being used
		this.projectProgram = wgl.createProgram(Shaders.Vertex.fullscreen, Shaders.Fragment.project);
		this.distanceConstraintProgram = wgl.createProgram(Shaders.Vertex.fullscreen, Shaders.Fragment.distanceconstraint);
		this.planeConstraintProgram = wgl.createProgram(Shaders.Vertex.fullscreen, Shaders.Fragment.planeconstraint);
		this.bendingConstraintProgram = wgl.createProgram(Shaders.Vertex.fullscreen, Shaders.Fragment.bendingconstraint);
		this.setBristlesProgram = wgl.createProgram(Shaders.Vertex.fullscreen, Shaders.Fragment.setbristles);
		this.updateVelocityProgram = wgl.createProgram(Shaders.Vertex.fullscreen, Shaders.Fragment.updatevelocity);

		// contains bristle vertex positions
		// we index bristle along x axis
		// we index vertices of bristles along y axis
		this.positionsTexture = wgl.buildTexture(wgl.RGBA, wgl.FLOAT, maxBristleCount, VERTICES_PER_BRISTLE, null, wgl.CLAMP_TO_EDGE, wgl.CLAMP_TO_EDGE, wgl.LINEAR, wgl.LINEAR);
		this.previousPositionsTexture = wgl.buildTexture(wgl.RGBA, wgl.FLOAT, maxBristleCount, VERTICES_PER_BRISTLE, null, wgl.CLAMP_TO_EDGE, wgl.CLAMP_TO_EDGE, wgl.LINEAR, wgl.LINEAR);
		this.velocitiesTexture = wgl.buildTexture(wgl.RGBA, wgl.FLOAT, maxBristleCount, VERTICES_PER_BRISTLE, null, wgl.CLAMP_TO_EDGE, wgl.CLAMP_TO_EDGE, wgl.LINEAR, wgl.LINEAR);
		this.previousVelocitiesTexture = wgl.buildTexture(wgl.RGBA, wgl.FLOAT, maxBristleCount, VERTICES_PER_BRISTLE, null, wgl.CLAMP_TO_EDGE, wgl.CLAMP_TO_EDGE, wgl.LINEAR, wgl.LINEAR);
		this.projectedPositionsTexture = wgl.buildTexture(wgl.RGBA, wgl.FLOAT, maxBristleCount, VERTICES_PER_BRISTLE, null, wgl.CLAMP_TO_EDGE, wgl.CLAMP_TO_EDGE, wgl.LINEAR, wgl.LINEAR);
		this.projectedPositionsTextureTemp = wgl.buildTexture(wgl.RGBA, wgl.FLOAT, maxBristleCount, VERTICES_PER_BRISTLE, null, wgl.CLAMP_TO_EDGE, wgl.CLAMP_TO_EDGE, wgl.LINEAR, wgl.LINEAR);

		let brushTextureCoordinates = [];
		for (let bristle = 0; bristle < maxBristleCount; ++bristle) {
			for (let vertex = 0; vertex < VERTICES_PER_BRISTLE; ++vertex) {
				let textureX = (bristle + 0.5) / maxBristleCount,
					textureY = (vertex + 0.5) / VERTICES_PER_BRISTLE;
				brushTextureCoordinates.push(textureX);
				brushTextureCoordinates.push(textureY);
			}
		}

		this.brushTextureCoordinatesBuffer = wgl.createBuffer();
		wgl.bufferData(this.brushTextureCoordinatesBuffer, wgl.ARRAY_BUFFER, new Float32Array(brushTextureCoordinates), wgl.STATIC_DRAW);

		let randoms = [];
		for (let i = 0; i < maxBristleCount * VERTICES_PER_BRISTLE * 4; ++i) {
			randoms.push(Math.random());
		}
		this.randomsTexture = wgl.buildTexture(wgl.RGBA, wgl.FLOAT, maxBristleCount, VERTICES_PER_BRISTLE, new Float32Array(randoms), wgl.CLAMP_TO_EDGE, wgl.CLAMP_TO_EDGE, wgl.LINEAR, wgl.LINEAR); // contains projected positions

		let splatsPerSegment = 8,
			splatCoordinates = [],
			splatIndices = [],
			splatIndex = 0;
		for (let bristle = 0; bristle < maxBristleCount; ++bristle) {
			for (let vertex = 0; vertex < VERTICES_PER_BRISTLE - 1; ++vertex) {
				// we create a quad for each bristle vertex
				for (let i = 0; i < splatsPerSegment; ++i) {
					let t = (i + 0.5) / splatsPerSegment,
						textureX = (bristle + 0.5) / maxBristleCount,
						textureY = (vertex + 0.5 + t) / VERTICES_PER_BRISTLE;
					// bottom left
					splatCoordinates.push(textureX);
					splatCoordinates.push(textureY);
					splatCoordinates.push(-1);
					splatCoordinates.push(-1);
					// bottom right
					splatCoordinates.push(textureX);
					splatCoordinates.push(textureY);
					splatCoordinates.push(1);
					splatCoordinates.push(-1);
					// top right
					splatCoordinates.push(textureX);
					splatCoordinates.push(textureY);
					splatCoordinates.push(1);
					splatCoordinates.push(1);
					// top left
					splatCoordinates.push(textureX);
					splatCoordinates.push(textureY);
					splatCoordinates.push(-1);
					splatCoordinates.push(1);

					splatIndices.push(splatIndex + 0);
					splatIndices.push(splatIndex + 1);
					splatIndices.push(splatIndex + 2);

					splatIndices.push(splatIndex + 2);
					splatIndices.push(splatIndex + 3);
					splatIndices.push(splatIndex + 0);

					splatIndex += 4;
				}
			}
		}

		this.splatCoordinatesBuffer = wgl.createBuffer();
		wgl.bufferData(this.splatCoordinatesBuffer, wgl.ARRAY_BUFFER, new Float32Array(splatCoordinates), wgl.STATIC_DRAW);

		this.splatIndexBuffer = wgl.createBuffer();
		wgl.bufferData(this.splatIndexBuffer, wgl.ELEMENT_ARRAY_BUFFER, new Uint16Array(splatIndices), wgl.STATIC_DRAW);

		this.splatIndexCount = splatIndices.length;

		let brushIndices = [];
		this.indexCount = 0;
		for (let bristle = 0; bristle < maxBristleCount; ++bristle) {
			for (let vertex = 0; vertex < VERTICES_PER_BRISTLE - 1; ++vertex) {
				let left = bristle * VERTICES_PER_BRISTLE + vertex,
					right = bristle * VERTICES_PER_BRISTLE + vertex + 1;

				brushIndices.push(left);
				brushIndices.push(right);

				this.indexCount += 2;
			}
		}

		this.brushIndexBuffer = wgl.createBuffer();
		wgl.bufferData(this.brushIndexBuffer, wgl.ELEMENT_ARRAY_BUFFER, new Uint16Array(brushIndices), wgl.STATIC_DRAW);

		this.simulationFramebuffer = wgl.createFramebuffer();

		this.quadVertexBuffer = wgl.createBuffer();
		wgl.bufferData(this.quadVertexBuffer, wgl.ARRAY_BUFFER, new Float32Array([-1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0]), wgl.STATIC_DRAW);
	}

	initialize(x, y, z, scale) {
		// sets all the bristle vertices
		this.positionX = x;
		this.positionY = y;
		this.positionZ = z;
		this.scale = scale;
		this.speeds = []; // most recent speed is stored at the highest index
		for (var i = 0; i < N_PREVIOUS_SPEEDS; ++i) {
			this.speeds.push(0);
		}

		var wgl = this.wgl;
		var setBristlesDrawState = wgl.createDrawState()
			.bindFramebuffer(this.simulationFramebuffer)
			.viewport(0, 0, this.bristleCount, VERTICES_PER_BRISTLE)
			.useProgram(this.setBristlesProgram)
			.uniform3f("u_brushPosition", this.positionX, this.positionY, this.positionZ)
			.uniform1f("u_brushScale", this.scale)
			.uniform1f("u_bristleCount", this.bristleCount)
			.uniform1f("u_bristleLength", BRISTLE_LENGTH)
			.uniform1f("u_verticesPerBristle", VERTICES_PER_BRISTLE)
			.uniform1f("u_jitter", BRISTLE_JITTER)
			.uniform2f("u_resolution", this.maxBristleCount, VERTICES_PER_BRISTLE)
			.uniformTexture("u_randomsTexture", 2, wgl.TEXTURE_2D, this.randomsTexture)
			.vertexAttribPointer(this.quadVertexBuffer, this.setBristlesProgram.getAttribLocation("a_position"), 2, wgl.FLOAT, false, 0, 0);

		wgl.framebufferTexture2D(this.simulationFramebuffer, wgl.FRAMEBUFFER, wgl.COLOR_ATTACHMENT0, wgl.TEXTURE_2D, this.positionsTexture, 0);
		wgl.drawArrays(setBristlesDrawState, wgl.TRIANGLE_STRIP, 0, 4);
	}

	get bristleCount() {
		return this._bristleCount;
	}

	set bristleCount(newBristleCount) {
		var wgl = this.wgl,
			bristleCount = this._bristleCount;

		// we set all the bristle vertices that weren"t previously being simulated
		if (newBristleCount > bristleCount * 100) {
			var setBristlesDrawState = wgl.createDrawState()
				.bindFramebuffer(this.simulationFramebuffer)
				.viewport(bristleCount, 0, (newBristleCount - bristleCount), VERTICES_PER_BRISTLE)
				.useProgram(this.setBristlesProgram)
				.uniform3f("u_brushPosition", this.positionX, this.positionY, this.positionZ)
				.uniform1f("u_brushScale", this.scale)
				.uniform1f("u_bristleCount", bristleCount)
				.uniform1f("u_bristleLength", BRISTLE_LENGTH)
				.uniform1f("u_verticesPerBristle", VERTICES_PER_BRISTLE)
				.uniform1f("u_jitter", BRISTLE_JITTER)
				.uniform2f("u_resolution", this.maxBristleCount, VERTICES_PER_BRISTLE)
				.uniformTexture("u_randomsTexture", 2, wgl.TEXTURE_2D, this.randomsTexture)
				.vertexAttribPointer(this.quadVertexBuffer, this.setBristlesProgram.getAttribLocation("a_position"), 2, wgl.FLOAT, false, 0, 0);

			wgl.framebufferTexture2D(this.simulationFramebuffer, wgl.FRAMEBUFFER, wgl.COLOR_ATTACHMENT0, wgl.TEXTURE_2D, this.positionsTexture, 0);
			wgl.drawArrays(setBristlesDrawState, wgl.TRIANGLE_STRIP, 0, 4);
		}

		this._bristleCount = newBristleCount;
	}

	// max of last N_PREVIOUS_SPEEDS speeds
	get filteredSpeed() {
		return this.speeds.reduce((a, b) => Math.max(a, b));
	}

	update(x, y, z, scale) {
		var dx = x - this.positionX,
			dy = y - this.positionY,
			dz = z - this.positionZ,
			speed = Math.sqrt(dx * dx + dy * dy + dz * dz);

		this.speeds.shift();
		this.speeds.push(speed);
		this.positionX = x;
		this.positionY = y;
		this.positionZ = z;
		this.scale = scale;

		var wgl = this.wgl;
		var projectDrawState = wgl.createDrawState()
			.bindFramebuffer(this.simulationFramebuffer)
			.viewport(0, 0, this._bristleCount, VERTICES_PER_BRISTLE)
			.useProgram(this.projectProgram)
			.uniformTexture("u_positionsTexture", 0, wgl.TEXTURE_2D, this.positionsTexture)
			.uniformTexture("u_velocitiesTexture", 1, wgl.TEXTURE_2D, this.velocitiesTexture)
			.uniformTexture("u_randomsTexture", 2, wgl.TEXTURE_2D, this.randomsTexture)
			.uniform1f("u_gravity", this.gravity)
			.uniform1f("u_damping", this.brushDamping)
			.uniform1f("u_verticesPerBristle", VERTICES_PER_BRISTLE)
			.uniform2f("u_resolution", this.maxBristleCount, VERTICES_PER_BRISTLE)
			.vertexAttribPointer(this.quadVertexBuffer, this.projectProgram.getAttribLocation("a_position"), 2, wgl.FLOAT, false, 0, 0);

		wgl.framebufferTexture2D(this.simulationFramebuffer, wgl.FRAMEBUFFER, wgl.COLOR_ATTACHMENT0, wgl.TEXTURE_2D, this.projectedPositionsTexture, 0);
		wgl.drawArrays(projectDrawState, wgl.TRIANGLE_STRIP, 0, 4);

		var setBristlesDrawState = wgl.createDrawState()
			.bindFramebuffer(this.simulationFramebuffer)
			.viewport(0, 0, this._bristleCount, 1)
			.useProgram(this.setBristlesProgram)
			.uniform3f("u_brushPosition", this.positionX, this.positionY, this.positionZ)
			.uniform1f("u_brushScale", this.scale)
			.uniform1f("u_bristleCount", this._bristleCount)
			.uniform1f("u_bristleLength", BRISTLE_LENGTH)
			.uniform1f("u_jitter", BRISTLE_JITTER)
			.uniform1f("u_verticesPerBristle", VERTICES_PER_BRISTLE)
			.uniform2f("u_resolution", this.maxBristleCount, VERTICES_PER_BRISTLE)
			.uniformTexture("u_randomsTexture", 2, wgl.TEXTURE_2D, this.randomsTexture)
			.vertexAttribPointer(this.quadVertexBuffer, this.setBristlesProgram.getAttribLocation("a_position"), 2, wgl.FLOAT, false, 0, 0);

		wgl.framebufferTexture2D(this.simulationFramebuffer, wgl.FRAMEBUFFER, wgl.COLOR_ATTACHMENT0, wgl.TEXTURE_2D, this.projectedPositionsTexture, 0);
		wgl.drawArrays(setBristlesDrawState, wgl.TRIANGLE_STRIP, 0, 4);

		for (var i = 0; i < ITERATIONS; ++i) {
			// sets the base position of each bristle by setting first vertex (first row)
			wgl.framebufferTexture2D(this.simulationFramebuffer, wgl.FRAMEBUFFER, wgl.COLOR_ATTACHMENT0, wgl.TEXTURE_2D, this.projectedPositionsTexture, 0);
			wgl.drawArrays(setBristlesDrawState, wgl.TRIANGLE_STRIP, 0, 4);

			for (var pass = 0; pass < 2; ++pass) {
				var constraintDrawState = wgl.createDrawState()
					.bindFramebuffer(this.simulationFramebuffer)
					.viewport(0, 0, this._bristleCount, VERTICES_PER_BRISTLE)
					.useProgram(this.distanceConstraintProgram)
					.uniformTexture("u_positionsTexture", 0, wgl.TEXTURE_2D, this.projectedPositionsTexture)
					.uniform1f("u_pointCount", VERTICES_PER_BRISTLE)
					.uniform1f("u_targetDistance", this.scale * BRISTLE_LENGTH / (VERTICES_PER_BRISTLE - 1))
					.uniform1i("u_pass", pass)
					.uniform2f("u_resolution", this.maxBristleCount, VERTICES_PER_BRISTLE)
					.vertexAttribPointer(this.quadVertexBuffer, this.distanceConstraintProgram.getAttribLocation("a_position"), 2, wgl.FLOAT, false, 0, 0);

				wgl.framebufferTexture2D(this.simulationFramebuffer, wgl.FRAMEBUFFER, wgl.COLOR_ATTACHMENT0, wgl.TEXTURE_2D, this.projectedPositionsTextureTemp, 0);
				wgl.drawArrays(constraintDrawState, wgl.TRIANGLE_STRIP, 0, 4);

				Utilities.swap(this, "projectedPositionsTexture", "projectedPositionsTextureTemp");
			}

			for (var pass = 0; pass < 3; ++pass) {
				var constraintDrawState = wgl.createDrawState()
					.bindFramebuffer(this.simulationFramebuffer)
					.viewport(0, 0, this._bristleCount, VERTICES_PER_BRISTLE)
					.useProgram(this.bendingConstraintProgram)
					.uniformTexture("u_positionsTexture", 0, wgl.TEXTURE_2D, this.projectedPositionsTexture)
					.uniformTexture("u_randomsTexture", 1, wgl.TEXTURE_2D, this.randomsTexture)
					.uniform1f("u_pointCount", VERTICES_PER_BRISTLE)
					.uniform1f("u_stiffnessVariation", this.stiffnessVariation)
					.uniform1i("u_pass", pass)
					.uniform2f("u_resolution", this.maxBristleCount, VERTICES_PER_BRISTLE)
					.vertexAttribPointer(this.quadVertexBuffer, this.bendingConstraintProgram.getAttribLocation("a_position"), 2, wgl.FLOAT, false, 0, 0);

				wgl.framebufferTexture2D(this.simulationFramebuffer, wgl.FRAMEBUFFER, wgl.COLOR_ATTACHMENT0, wgl.TEXTURE_2D, this.projectedPositionsTextureTemp, 0);
				wgl.drawArrays(constraintDrawState, wgl.TRIANGLE_STRIP, 0, 4);

				Utilities.swap(this, "projectedPositionsTexture", "projectedPositionsTextureTemp");
			}

			var constraintDrawState = wgl.createDrawState()
				.bindFramebuffer(this.simulationFramebuffer)
				.viewport(0, 0, this._bristleCount, VERTICES_PER_BRISTLE)
				.useProgram(this.planeConstraintProgram)
				.uniformTexture("u_positionsTexture", 0, wgl.TEXTURE_2D, this.projectedPositionsTexture)
				.uniform2f("u_resolution", this.maxBristleCount, VERTICES_PER_BRISTLE)
				.vertexAttribPointer(this.quadVertexBuffer, this.planeConstraintProgram.getAttribLocation("a_position"), 2, wgl.FLOAT, false, 0, 0);

			wgl.framebufferTexture2D(this.simulationFramebuffer, wgl.FRAMEBUFFER, wgl.COLOR_ATTACHMENT0, wgl.TEXTURE_2D, this.projectedPositionsTextureTemp, 0);
			wgl.drawArrays(constraintDrawState, wgl.TRIANGLE_STRIP, 0, 4);

			Utilities.swap(this, "projectedPositionsTexture", "projectedPositionsTextureTemp");
		}

		var updateVelocityDrawState = wgl.createDrawState()
			.bindFramebuffer(this.simulationFramebuffer)
			.viewport(0, 0, this._bristleCount, VERTICES_PER_BRISTLE)
			.useProgram(this.updateVelocityProgram)
			.uniformTexture("u_positionsTexture", 0, wgl.TEXTURE_2D, this.positionsTexture)
			.uniformTexture("u_projectedPositionsTexture", 1, wgl.TEXTURE_2D, this.projectedPositionsTexture)
			.uniform2f("u_resolution", this.maxBristleCount, VERTICES_PER_BRISTLE)
			.vertexAttribPointer(this.quadVertexBuffer, this.distanceConstraintProgram.getAttribLocation("a_position"), 2, wgl.FLOAT, false, 0, 0);

		wgl.framebufferTexture2D(this.simulationFramebuffer, wgl.FRAMEBUFFER, wgl.COLOR_ATTACHMENT0, wgl.TEXTURE_2D, this.previousVelocitiesTexture, 0);
		wgl.drawArrays(updateVelocityDrawState, wgl.TRIANGLE_STRIP, 0, 4);

		Utilities.swap(this, "velocitiesTexture", "previousVelocitiesTexture");
		Utilities.swap(this, "previousPositionsTexture", "positionsTexture");
		Utilities.swap(this, "positionsTexture", "projectedPositionsTexture");
	}

}


var WIDTH = 240,
	HEIGHT = 200,
	//coordinates are all relative to [left, bottom]
	ALPHA_SLIDER_X = 210,
	ALPHA_SLIDER_Y = 5,
	ALPHA_SLIDER_WIDTH = 20,
	ALPHA_SLIDER_HEIGHT = 190,
	//center of the hue circle
	CIRCLE_X = 100,
	CIRCLE_Y = 100,
	INNER_RADIUS = 77,
	OUTER_RADIUS = 95,
	//dimensions of the inner saturation brightness square
	SQUARE_WIDTH = (INNER_RADIUS - 5) * Math.sqrt(2);


class ColorPicker {
	constructor(el, painter, wgl) {
		// references to elements
		this._el = el;
		this._doc = $(document);
		this._debug = false;
		// bind event handlers
		this._el.parent().on("mousedown", this.move);
		// prepare shader program
		this.pickerProgram = wgl.createProgram(Shaders.Vertex.picker, Shaders.Fragment.picker, { "a_position": 0 });
		// this.pickerProgram = wgl.createProgram(Shaders.Vertex.picker, "#define RGB \n "+ Shaders.Fragment.picker, { "a_position": 0 });
		this.quadVertexBuffer = wgl.createBuffer();
		wgl.bufferData(this.quadVertexBuffer, wgl.ARRAY_BUFFER, new Float32Array([-1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0]), wgl.STATIC_DRAW);
		// initial paint
		this.draw();
		// for dev / debug purposes
		if (this._debug) {
			el.parent().addClass("debug");
		}
	}

	draw() {
		let wgl = STUDIO.wgl;
		//we first render the painting to a WebGL texture
		let pickerTexture = wgl.buildTexture(wgl.RGBA, wgl.UNSIGNED_BYTE, WIDTH, HEIGHT, null, wgl.CLAMP_TO_EDGE, wgl.CLAMP_TO_EDGE, wgl.NEAREST, wgl.NEAREST);
		let pickerFramebuffer = wgl.createFramebuffer();
		wgl.framebufferTexture2D(pickerFramebuffer, wgl.FRAMEBUFFER, wgl.COLOR_ATTACHMENT0, wgl.TEXTURE_2D, pickerTexture, 0);
		
		let hsva = STUDIO.painter.brushColorHSVA;
		let pickerDrawState = wgl.createDrawState()
			.bindFramebuffer(pickerFramebuffer)
			.viewport(0, 0, WIDTH, HEIGHT)
			.vertexAttribPointer(this.quadVertexBuffer, 0, 2, wgl.FLOAT, wgl.FALSE, 0, 0)
			.useProgram(this.pickerProgram)
			.uniform2f("u_resolution", WIDTH, HEIGHT)
			.uniform1f("u_innerRadius", INNER_RADIUS)
			.uniform1f("u_outerRadius", OUTER_RADIUS)
			.uniform1f("u_squareWidth", SQUARE_WIDTH)
			.uniform2f("u_circlePosition", CIRCLE_X, CIRCLE_Y)
			.uniform2f("u_alphaSliderPosition", ALPHA_SLIDER_X, ALPHA_SLIDER_Y)
			.uniform2f("u_alphaSliderDimensions", ALPHA_SLIDER_WIDTH, ALPHA_SLIDER_HEIGHT)
			.uniform4f("u_currentHSVA", hsva[0], hsva[1], hsva[2], hsva[3])
			.uniform2f("u_screenResolution", WIDTH, HEIGHT)
			.uniform2f("u_position", 0, 0)
			.uniform2f("u_dimensions", WIDTH, HEIGHT);
			// .enable(wgl.BLEND)
			// .blendFunc(wgl.ONE, wgl.ONE_MINUS_SRC_ALPHA); //premultiplied alpha

		wgl.drawArrays(pickerDrawState, wgl.TRIANGLE_STRIP, 0, 4);

		//then we read back this texture
		let pixels = new Uint8Array(WIDTH * HEIGHT * 4);
		wgl.readPixels(wgl.createReadState().bindFramebuffer(pickerFramebuffer), 0, 0, WIDTH, HEIGHT, wgl.RGBA, wgl.UNSIGNED_BYTE, pixels);
		wgl.deleteTexture(pickerTexture);
		wgl.deleteFramebuffer(pickerFramebuffer);

		// dim of canvas
		this._el.prop({ width: WIDTH, height: HEIGHT });
		// draw canvas element
		let ctx = this._el[0].getContext("2d"),
			imgData = ctx.createImageData(WIDTH, HEIGHT);
		imgData.data.set(pixels);
		ctx.putImageData(imgData, 0, 0);
	}

	move(event) {
		let Self = STUDIO.picker,
			Drag = Self.drag,
			mY,
			mX;
		switch (event.type) {
			case "mousedown":
				// prepare drag event
				let el = $(event.target),
					type = el.prop("className"),
					rect = el[0].parentNode.getBoundingClientRect(),
					painter = STUDIO.painter,
					hsva = painter.brushColorHSVA,
					_PI = 180 / Math.PI,
					min = { x: 0, y: 0 },
					max = { x: 0, y: 0 },
					click = {
						y: event.clientY,
						x: event.clientX,
					};
				// operate on parent (root) element
				el = el.parent();
				switch (type) {
					case "picker-ring":
						mY = event.offsetY - 96;
						mX = event.offsetX - 96;
						click.deg = Math.round(Math.atan2(mY, mX) * _PI) + 90;
						if (click.deg < 0) click.deg += 360;
						click.y = rect.top + 111;
						click.x = rect.left + 111;
						break;
					case "picker-box":
						max.x = 82;
						max.y = 82;
						click.y -= event.offsetY;
						click.x -= event.offsetX;
						mY = Math.min(Math.max(event.offsetY - 10, min.y), max.y);
						mX = Math.min(Math.max(event.offsetX - 10, min.x), max.x);
						break;
					case "picker-alpha":
						max.y = 170;
						click.y -= event.offsetY;
						mY = Math.min(Math.max(event.offsetY - 10, min.y), max.y);
						break;
					default: return;
				}

				Self.drag = {
					el,
					min,
					max,
					_PI,
					type,
					hsva,
					click,
					painter,
					_min: Math.min,
					_max: Math.max,
					_round: Math.round,
					_atan2: Math.atan2,
				};
				// fake trigger event to update interface
				Self.move({
					type: "mousemove",
					clientX: event.clientX,
					clientY: event.clientY,
				});
				// bind event handler
				Self._doc.on("mousemove mouseup", Self.move);
				break;
			case "mousemove":
				let data = {},
					deg;
				switch (Drag.type) {
					case "picker-ring":
						mY = event.clientY - Drag.click.y;
						mX = event.clientX - Drag.click.x;
						deg = Drag._round(Drag._atan2(mY, mX) * Drag._PI) + 90;
						data["--cp-hue"] = `${deg}deg`;
						// update hue value of HSVA
						Drag.hsva[0] = ((deg + 270) % 360) / 360;
						// console.log( Drag.hsva );
						break;
					case "picker-box":
						mY = Drag._min(Drag._max(event.clientY - Drag.click.y - 10, Drag.min.y), Drag.max.y);
						mX = Drag._min(Drag._max(event.clientX - Drag.click.x - 10, Drag.min.x), Drag.max.x);
						data["--cp-slY"] = `${mY}px`;
						data["--cp-slX"] = `${mX}px`;
						// update saturation / lightness values of HSVA
						Drag.hsva[1] = mX / Drag.max.x;
						Drag.hsva[2] = mY / Drag.max.y;
						break;
					case "picker-alpha":
						mY = Drag._min(Drag._max(event.clientY - Drag.click.y - 10, Drag.min.y), Drag.max.y);
						data["--cp-alpha"] = `${mY}px`;
						// update alpha value of HSVA
						Drag.hsva[3] = mY / Drag.max.y;
						break;
				}
				if (Self._debug) Drag.el.css(data);
				Drag.painter.brushColorHSVA = Drag.hsva;
				Self.draw();
				break;
			case "mouseup":
				// unbind event handler
				Self._doc.off("mousemove mouseup", Self.move);
				break;
		}
	}
}


class Rectangle {
	constructor(left, bottom, width, height) {
		this._left = left;
		this._bottom = bottom;
		this._width = width;
		this._height = height;
	}

	get left() { return this._left; }
	set left(v) { this._left = v; }

	get bottom() { return this._bottom; }
	set bottom(v) { this._bottom = v; }

	get width() { return this._width; }
	set width(v) { this._width = v; }

	get height() { return this._height; }
	set height(v) { this._height = v; }

	get right() { return this._left + this._width; }
	set right(v) { this._width = v - this._left; }

	get top() { return this._bottom + this._height; }
	set top(v) { this._height = v - this._bottom; }

	clone() {
		return new Rectangle(this.left, this.bottom, this.width, this.height);
	}

	includeRectangle(rectangle) {
		var newRight = Math.max(this.right, rectangle.right),
			newTop = Math.max(this.top, rectangle.top);
		this._left = Math.min(this.left, rectangle.left);
		this._bottom = Math.min(this.bottom, rectangle.bottom);
		this.right = newRight;
		this.top = newTop;
		return this;
	}

	intersectRectangle(rectangle) {
		var newRight = Math.min(this.right, rectangle.right),
			newTop = Math.min(this.top, rectangle.top);
		this._left = Math.max(this.left, rectangle.left);
		this._bottom = Math.max(this.bottom, rectangle.bottom);
		this.right = newRight;
		this.top = newTop;
		return this;
	}

	translate(x, y) {
		this._left += x;
		this._bottom += y;
		return this;
	}

	scale(x, y) {
		this._left *= x;
		this._bottom *= y;
		this._width *= x;
		this._height *= y;
		return this;
	}

	round() {
		this._left = Math.round(this._left);
		this._bottom = Math.round(this._bottom);
		this._width = Math.round(this._width);
		this._height = Math.round(this._height);
	}

	getArea() {
		return this.width * this.height;
	}
}



class State {
	constructor(wgl) {
		this.wgl = wgl;

		//all states that have been changed from defaults
		this.changedParameters = {};
		//map of state string to array of values
		//eg
		/*
			"framebuffer: [framebuffer],
			"viewport": [x, y, width, height],
			"blendMode": [rgb, alpha]
		*/
	}

	setParameter(parameterName, values) {
		//if the state hasn"t been set to the defaults
		if (!arraysEqual(values, this.wgl.parameters[parameterName].defaults)) {
			this.changedParameters[parameterName] = values;
		} else { //if we"re going back to defaults
			if (this.changedParameters.hasOwnProperty(parameterName)) {
				delete this.changedParameters[parameterName];
			}
		}
	}

	clone() {
		var newState = new (this.constructor)(this.wgl);

		for (var parameterName in this.changedParameters) {
			if (this.changedParameters.hasOwnProperty(parameterName)) {
				var parameterValues = this.changedParameters[parameterName];
				var clonedValues = [];
				for (var i = 0; i < parameterValues.length; ++i) {
					clonedValues.push(parameterValues[i]);
				}
				newState.changedParameters[parameterName] = clonedValues;
			}
		}

		return newState;
	}
}


class DrawState extends State {
	constructor(wgl) {
		super(wgl, wgl);

		// we always set uniforms
		this.uniforms = {}; // eg: {type: "3f", value: [x, y, z]}
	}

	bindFramebuffer(framebuffer) {
		this.setParameter("framebuffer", [framebuffer]);
		return this;
	}
	
	viewport(x, y, width, height) {
		this.setParameter("viewport", [x, y, width, height]);
		return this;
	}
	
	enable(cap) {
		if (cap === this.wgl.DEPTH_TEST) {
			this.setParameter("depthTest", [true]);
		} else if (cap === this.wgl.BLEND) {
			this.setParameter("blend", [true]);
		} else if (cap === this.wgl.CULL_FACE) {
			this.setParameter("cullFace", [true]);
		} else if (cap === this.wgl.POLYGON_OFFSET_FILL) {
			this.setParameter("polygonOffsetFill", [true]);   
		} else if (cap === this.wgl.SCISSOR_TEST) {
			this.setParameter("scissorTest", [true]);
		}
		return this;
	}
	
	disable(cap) {
		if (cap === this.wgl.DEPTH_TEST) {
			this.setParameter("depthTest", [false]);
		} else if (cap === this.wgl.BLEND) {
			this.setParameter("blend", [false]);
		} else if (cap === this.wgl.CULL_FACE) {
			this.setParameter("cullFace", [false]);
		} else if (cap === this.wgl.POLYGON_OFFSET_FILL) {
			this.setParameter("polygonOffsetFill", [false]);   
		} else if (cap === this.wgl.SCISSOR_TEST) {
			this.setParameter("scissorTest", [false]);
		}
		return this;
	}
	
	vertexAttribPointer(buffer, index, size, type, normalized, stride, offset) {
		this.setParameter("attributeArray" + index.toString(), [buffer, size, type, normalized, stride, offset]);

		if (this.instancedExt && this.changedParameters.hasOwnProperty("attributeDivisor" + index.toString())) {
			// we need to have divisor information for any attribute location that has a bound buffer
			this.setParameter("attributeDivisor" + index.toString(), [0]);
		}
		return this;
	}
	
	bindIndexBuffer(buffer) {
		this.setParameter("indexBuffer", [buffer]);
		return this;
	}
	
	depthFunc(func) {
		this.setParameter("depthFunc", [func]);
		return this;
	}
	
	frontFace(mode) {
		this.setParameter("frontFace", [mode]);
		return this;
	}
	
	blendEquation(mode) {
		this.blendEquationSeparate(mode, mode);
		return this;
	}
	
	blendEquationSeparate(modeRGB, modeAlpha) {
		this.setParameter("blendEquation", [modeRGB, modeAlpha]);
		return this;
	}
	
	blendFunc(sFactor, dFactor) {
		this.blendFuncSeparate(sFactor, dFactor, sFactor, dFactor);
		return this;
	}
	
	blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha) {
		this.setParameter("blendFunc", [srcRGB, dstRGB, srcAlpha, dstAlpha]);
		return this;
	}
	
	scissor(x, y, width, height) {
		this.setParameter("scissor", [x, y, width, height]);
		return this;
	}
	
	useProgram(program) {
		this.setParameter("program", [program]);
		return this;
	}
	
	bindTexture(unit, target, texture) {
		this.setParameter("texture" + unit.toString(), [target, texture]);
		return this;
	}
	
	colorMask(r, g, b, a) {
		this.setParameter("colorMask", [r, g, b, a]);
		return this;
	}
	
	depthMask(enabled) {
		this.setParameter("depthMask", [enabled]);
		return this;
	}
	
	polygonOffset(factor, units) {
		this.setParameter("polygonOffset", [factor, units]);
		return this;
	}
	
	uniformTexture(uniformName, unit, target, texture) {
		this.uniform1i(uniformName, unit);
		this.bindTexture(unit, target, texture);
		return this;
	}
	
	uniform1i(uniformName, value) {
		this.uniforms[uniformName] = {type: "1i", value: [value]};
		return this;
	}
	
	uniform2i(uniformName, x, y) {
		this.uniforms[uniformName] = {type: "2i", value: [x, y]};
		return this;
	}
	
	uniform3i(uniformName, x, y, z) {
		this.uniforms[uniformName] = {type: "3i", value: [x, y, z]};
		return this;
	}
	
	uniform4i(uniformName, x, y, z ,w) {
		this.uniforms[uniformName] = {type: "4i", value: [x, y, z, w]};
		return this;
	}
	
	uniform1f(uniformName, value) {
		this.uniforms[uniformName] = {type: "1f", value: value};
		return this;
	}
	
	uniform2f(uniformName, x, y) {
		this.uniforms[uniformName] = {type: "2f", value: [x, y]};
		return this;
	}
	
	uniform3f(uniformName, x, y, z) {
		this.uniforms[uniformName] = {type: "3f", value: [x, y, z]};
		return this;
	}
	
	uniform4f(uniformName, x, y, z ,w) {
		this.uniforms[uniformName] = {type: "4f", value: [x, y, z, w]};
		return this;
	}
	
	uniform1fv(uniformName, value) {
		this.uniforms[uniformName] = {type: "1fv", value: [value]};
		return this;
	}
	
	uniform2fv(uniformName, value) {
		this.uniforms[uniformName] = {type: "2fv", value: [value]};
		return this;
	}
	
	uniform3fv(uniformName, value) {
		this.uniforms[uniformName] = {type: "3fv", value: [value]};
		return this;
	}
	
	uniform4fv(uniformName, value) {
		this.uniforms[uniformName] = {type: "4fv", value: [value]};
		return this;
	}
	
	uniformMatrix2fv(uniformName, transpose, matrix) {
		this.uniforms[uniformName] = {type: "matrix2fv", value: [transpose, matrix]};
		return this;
	}
	
	uniformMatrix3fv(uniformName, transpose, matrix) {
		this.uniforms[uniformName] = {type: "matrix3fv", value: [transpose, matrix]};
		return this;
	}
	
	uniformMatrix4fv(uniformName, transpose, matrix) {
		this.uniforms[uniformName] = {type: "matrix4fv", value: [transpose, matrix]};
		return this;
	}
	
}


class ClearState extends State {
	constructor(wgl) {
		super(wgl, wgl);
	}

	bindFramebuffer(framebuffer) {
		this.setParameter("framebuffer", [framebuffer]);
		return this;
	}

	clearColor(r, g, b, a) {
		console.log( [r, g, b, a] );
		this.setParameter("clearColor", [r, g, b, a]);
		return this;
	}

	clearDepth(depth) {
		this.setParameter("clearDepth", [depth]);
		return this;
	}
	colorMask(r, g, b, a) {
		this.setParameter("colorMask", [r, g, b, a]);
		return this;
	}

	depthMask(enabled) {
		this.setParameter("depthMask", [enabled]);
		return this;
	}

	enable(cap) {
		if (cap === this.wgl.SCISSOR_TEST) {
			this.setParameter("scissorTest", [true]);
		}
		return this;
	}
	
	disable(cap) {
		if (cap === this.wgl.SCISSOR_TEST) {
			this.setParameter("scissorTest", [false]);
		}
		return this;
	}

	scissor(x, y, width, height) {
		this.setParameter("scissor", [x, y, width, height]);
		return this;
	}
}


class ReadState extends State {
	constructor(wgl) {
		super(wgl, wgl);
	}

	bindFramebuffer(framebuffer) {
		this.setParameter("framebuffer", [framebuffer]);
		return this;
	}
}


// we don"t have to specify any or all attribute location bindings
// any unspecified bindings will be assigned automatically and can be
// queried with program.getAttribLocation(attributeName)
	
class WrappedProgram {
	constructor(wgl, vertexShaderSource, fragmentShaderSource, requestedAttributeLocations) {
		this.uniformLocations = {};
		this.uniforms = {}; // TODO: if we want to cache uniform values in the future

		let gl = wgl.gl;

		// build shaders from source
		let vertexShader = buildShader(gl, gl.VERTEX_SHADER, vertexShaderSource),
			fragmentShader = buildShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

		// create program and attach shaders
		let program = this.program = gl.createProgram();
		gl.attachShader(program, vertexShader);
		gl.attachShader(program, fragmentShader);
		
		// bind the attribute locations that have been specified in attributeLocations
		if (requestedAttributeLocations !== undefined) {
			for (let attributeName in requestedAttributeLocations) {
				gl.bindAttribLocation(program, requestedAttributeLocations[attributeName], attributeName);
			}
		}
		gl.linkProgram(program);

		// construct this.attributeLocations (maps attribute names to locations)
		this.attributeLocations = {};
		let numberOfAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
		for (let i = 0; i < numberOfAttributes; ++i) {
			let activeAttrib = gl.getActiveAttrib(program, i);
			let attributeName = activeAttrib.name;
			this.attributeLocations[attributeName] = gl.getAttribLocation(program, attributeName);
		}

		// cache uniform locations
		let uniformLocations = this.uniformLocations = {};
		let numberOfUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
		for (let i = 0; i < numberOfUniforms; i += 1) {
			let activeUniform = gl.getActiveUniform(program, i),
				uniformLocation = gl.getUniformLocation(program, activeUniform.name);
			uniformLocations[activeUniform.name] = uniformLocation;
		}
	}

	// TODO: maybe this should be on WrappedGL?
	getAttribLocation(name) {
		return this.attributeLocations[name];
	}
}



const Color = {
	rgbToLightness(r, g, b) {
		return (1/2 * (Math.max(r, g, b) + Math.min(r, g, b))) / 255;
	},
	rgbToSaturation(r, g, b) {
		let L = this.rgbToLightness(r, g, b),
			max = Math.max(r, g, b),
			min = Math.min(r, g, b);
		return (L === 0 || L === 1)
			? 0
			: ((max - min) / (1 - Math.abs(2 * L - 1))) / 255;
	},
	rgbToHue(r, g, b) {
		let hue = Math.round(Math.atan2(Math.sqrt(3) * (g - b), 2 * r - g - b) * 180 / Math.PI );
		return hue < 0 ? hue + 360 : hue;
	},
	hslToRgb(h, s, l, a=1) {
		let _round = Math.round,
			_min = Math.min,
			_max = Math.max,
			b = s * _min(l, 1-l);
		let f = (n, k = (n + h / 30) % 12) => l - b * _max(_min(k - 3, 9 - k, 1), -1);
		return [_round(f(0) * 255), _round(f(8) * 255), _round(f(4) * 255), a];
	},
	hslToHex(h, s, l, a=1) {
		let rgb = this.hslToRgb(h, s, l, a);
		return this.rgbToHex(`rgba(${rgb.join(",")})`);
	},
	hexToHsl(hex) {
		let rgb = this.hexToRgb(hex);
		return this.rgbToHsl(...rgb);
	},
	mixColors(hex1, hex2, p) {
		let rgb1 = this.hexToRgb(hex1),
			rgb2 = this.hexToRgb(hex2),
			w = p * 2 - 1,
			w1 = (w + 1) / 2.0,
			w2 = 1 - w1,
			rgb = [
				parseInt(rgb1[0] * w1 + rgb2[0] * w2, 10),
				parseInt(rgb1[1] * w1 + rgb2[1] * w2, 10),
				parseInt(rgb1[2] * w1 + rgb2[2] * w2, 10),
				rgb1[3] * w1 + rgb2[3] * w2
			];
		return this.rgbToHex(`rgba(${rgb.join(",")})`);
	},
	hexToHsv(hex) {
		let rgb = this.hexToRgb(hex);
		return this.rgbToHsv(...rgb);
	},
	rgbToHsv(r, g, b, a=1) {
		var max = Math.max(r, g, b), min = Math.min(r, g, b),
			d = max - min,
			h,
			s = (max === 0 ? 0 : d / max),
			v = max / 255;
		switch (max) {
			case min: h = 0; break;
			case r: h = (g - b) + d * (g < b ? 6: 0); h /= 6 * d; break;
			case g: h = (b - r) + d * 2; h /= 6 * d; break;
			case b: h = (r - g) + d * 4; h /= 6 * d; break;
		}
		return [h, s, v, a];
	},
	hexToRgb(hex) {
		let r = parseInt(hex.substr(1,2), 16),
			g = parseInt(hex.substr(3,2), 16),
			b = parseInt(hex.substr(5,2), 16),
			a = parseInt(hex.substr(7,2) || "ff", 16) / 255;
		return [r, g, b, a];
	},
	rgbToHsl(r, g, b, a=1) {
		r /= 255;
		g /= 255;
		b /= 255;
		var max = Math.max(r, g, b),
			min = Math.min(r, g, b),
			l = (max + min) / 2,
			h, s;
		if (max == min){
			h = s = 0; // achromatic
		} else {
			var d = max - min;
			s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
			switch (max){
				case r: h = (g - b) / d + (g < b ? 6 : 0); break;
				case g: h = (b - r) / d + 2; break;
				case b: h = (r - g) / d + 4; break;
			}
			h /= 6;
		}
		return [h, s, l, a];
	},
	rgbToHex(rgb) {
		let d = "0123456789abcdef".split(""),
			hex = x => isNaN(x) ? "00" : d[( x - x % 16) / 16] + d[x % 16];
		rgb = rgb.match(/^rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\.\d]+)\)$/);
		if (!rgb) rgb = arguments[0].match(/^rgb?\((\d+),\s*(\d+),\s*(\d+)\)$/);
		let a = Math.round((rgb[4] || 1) * 255);
		return "#"+ hex(rgb[1]) + hex(rgb[2]) + hex(rgb[3]) + hex(a);
	}
};


const UI = {
	init() {
		// fast references
		this.doc = $(document);
		this.content = window.find("content");

		this.content.find(".knob[data-change]").map(item => {
			let el = $(item),
				min = +el.data("min"),
				max = +el.data("max"),
				val = +el.data("value"),
				value = Math.round((val / max) * 100);

			el.data({ value });
			el.nextAll(".value").html(val);
		});

		// bind event handlers
		this.content.on("mousedown", ".knob, .pan-knob", this.doKnob);
	},
	doKnob(event) {
		let APP = goya,
			Self = UI,
			Drag = Self.drag,
			name,
			value,
			type,
			el;
		switch (event.type) {
			case "mousedown":
				// prevent default behaviour
				event.preventDefault();

				el = $(event.target);
				value = +el.data("value");

				Self.drag = {
					el,
					value,
					type: el.data("change"),
					arg: el.data("arg"),
					clientY: event.clientY,
					clientX: event.clientX,
					min: el.hasClass("pan-knob") ? -50 : 0,
					max: el.hasClass("pan-knob") ? 50 : 100,
					val: {
						el: el.parent().find(".value"),
						min: el.hasClass("pan-knob") ? 0 : +el.data("min"),
						max: +el.data("max") - +el.data("min"),
						step: +el.data("step") || 1,
					}
				};

				// bind event handlers
				Self.content.addClass("no-cursor");
				Self.doc.on("mousemove mouseup", Self.doKnob);
				break;
			case "mousemove":
				value = Math.round((Drag.clientY - event.clientY) + Drag.value);
				value = Math.min(Math.max(value, Drag.min), Drag.max);
				Drag.el.data({ value });

				let i = Drag.val.step.toString().split(".")[1],
					val = (Drag.val.max * (value / 100)) + Drag.val.min;

				Drag.val.el.html(val.toFixed(i ? i.length : 0));
				break;
			case "mouseup":
				// unbind event handlers
				Self.content.removeClass("no-cursor");
				Self.doc.off("mousemove mouseup", Self.doKnob);

				// emit change event
				type = Drag.type;
				value = +Drag.val.el.text();
				if (type) {
					APP.sidebar.dispatch({ type, arg: Drag.arg, value });
				}
				break;
		}
	}
};

UI.init();
